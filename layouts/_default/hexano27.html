<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html lang="en">
<!--
Copyright (c) 2025 Hyperagon

Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
-->
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Hexano</title>
    <style type="text/css">
        /* --- Basic Setup & Theme --- */
        html, body {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            background-color: #1a1a1a;
            color: #e0e0e0;
            font-family: Courier, CourierNew, sans-serif;
            font-weight: bold;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
            -webkit-touch-callout: none;
        }

        /* --- Main Layout --- */
        .app-container {
            display: block;
            width: 100%;
            height: 100%;
            position: relative;
        }

        .hexboard {
            position: absolute;
            top: 54px;
            left: 0;
            right: 0;
            bottom: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            overflow: auto;
        }

        /* --- Control Bar --- */
        .control-bar {
            display: block;
            position: relative;
            padding: 10px 20px;
            background-color: #2a2a2a;
            border-bottom: 1px solid #000;
            z-index: 10;
            text-align: center;
        }
        
        .control-bar button, .control-bar select {
            background: none;
            border: none;
            color: #e0e0e0;
            cursor: pointer;
            font-size: 16px;
            margin: 0 5px;
            vertical-align: middle;
        }

        .control-bar select {
            background-color: #333;
            border: 1px solid #555;
            padding: 5px;
        }

        .control-bar input[type="range"] {
            width: 100px;
            cursor: pointer;
            vertical-align: middle;
        }
        
        #record-button {
            width: 32px;
            height: 32px;
            border: 2px solid #e0e0e0;
            border-radius: 50%;
            display: inline-block;
            position: relative;
            transition: border-color 0.2s, box-shadow 0.3s;
        }

        #record-button.recording {
            border-color: #ff4136;
            animation: pulse 1.5s infinite;
        }

        #record-indicator {
            width: 18px;
            height: 18px;
            background-color: #ff4136;
            border-radius: 50%;
            position: absolute;
            top: 50%;
            left: 50%;
            margin-top: -9px;
            margin-left: -9px;
            transform: scale(0);
            transition: transform 0.2s ease-in-out;
        }

        #record-button.recording #record-indicator {
            transform: scale(1);
        }

        #play-button, #fullscreen-button {
            width: 32px;
            height: 32px;
            padding: 0;
            display: inline-block;
            vertical-align: middle;
            position: relative;
        }

        .icon {
            width: 100%;
            height: 100%;
            fill: currentColor;
        }

        /* --- Melody Panel --- */
        .overlay-panel {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 600px;
            height: 400px;
            background-color: #333;
            border: 2px solid #555;
            border-radius: 10px;
            z-index: 1000;
            display: none;
            box-shadow: 0 5px 25px rgba(0, 0, 0, 0.8);
            flex-direction: column;
            padding: 20px;
            box-sizing: border-box;
        }

        .overlay-panel.active {
            display: flex;
        }

        .overlay-panel .close-btn {
            position: absolute;
            top: 10px;
            right: 10px;
            width: 30px;
            height: 30px;
            background-color: #555;
            border: none;
            border-radius: 50%;
            color: #e0e0e0;
            font-size: 18px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .overlay-panel .close-btn:hover {
            background-color: #666;
        }

        .panel-header {
            text-align: center;
            margin-bottom: 10px;
        }

        .panel-header h2 {
            margin: 0;
            padding: 0;
        }

        .panel-content {
            flex-grow: 1;
            overflow-y: auto;
            background-color: #222;
            border-radius: 5px;
            padding: 10px;
            margin-bottom: 15px;
        }

        .note-list-header {
            display: flex;
            padding: 5px 10px;
            border-bottom: 2px solid #555;
            font-weight: bold;
            color: #e0e0e0;
        }

        .note-item {
            display: flex;
            padding: 5px 10px;
            border-bottom: 1px solid #444;
            align-items: center;
        }

        .note-item:last-child {
            border-bottom: none;
        }

        .note-name {
            font-weight: bold;
            flex: 1;
            text-align: center;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .note-freq {
            color: #aaa;
            flex: 1;
            text-align: center;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .note-time {
            color: #aaa;
            flex: 1;
            text-align: center;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .note-duration {
            color: #aaa;
            flex: 1;
            text-align: center;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .panel-buttons {
            display: flex;
            justify-content: space-between;
        }

        .panel-button {
            background-color: #444;
            border: 1px solid #666;
            border-radius: 5px;
            color: #e0e0e0;
            padding: 8px 15px;
            cursor: pointer;
            transition: background-color 0.2s;
        }

        .panel-button:hover {
            background-color: #555;
        }

        /* --- Wave Type Selector --- */
        .wave-selector {
            display: inline-flex;
            margin: 0 5px;
            vertical-align: middle;
        }

        .wave-option {
            width: 60px;
            height: 30px;
            background-color: #333;
            border: 1px solid #555;
            margin: 0 2px;
            cursor: pointer;
            position: relative;
            transition: all 0.2s;
        }

        .wave-option:hover {
            background-color: #444;
        }

        .wave-option.selected {
            background-color: #555;
            border-color: #777;
        }

        .wave-option svg {
            width: 100%;
            height: 100%;
        }

        .wave-option path {
            stroke: #e0e0e0;
            stroke-width: 1.5;
            fill: none;
        }

        /* --- SVG Piano Styling --- */
        .piano-svg {
            display: block;
            transform: rotate(0deg);
        }
        
        .hexagon {
            cursor: pointer;
            stroke: black;
            stroke-width: 1px;
            transition: fill 0.05s ease-in-out;
        }

        .note-text {
            fill: white;
            stroke: black;
            stroke-width: 1px;
            text-anchor: middle;
            font-size: 180%;
            font-weight: bold;
            pointer-events: none;
        }
        
        .note-key {
            fill: #e0e0e0;
            stroke: black;
            stroke-width: 1px;
            text-anchor: middle;
            font-size: 120%;
            font-weight: normal;
            pointer-events: none;
        }

        /* Note specific colors - SOLID OPAQUE COLORS */
        .hexagon[data-note-name^="C"]:not([data-note-name*="#"]) { 
            fill: rgba(231, 76, 60, 1);
        }

        .hexagon[data-note-name^="D"]:not([data-note-name*="#"]) { 
            fill: rgba(241, 196, 15, 1); 
        }

        .hexagon[data-note-name^="E"] { 
            fill: rgba(46, 204, 113, 1); 
        }

        .hexagon[data-note-name^="F"]:not([data-note-name*="#"]) { 
            fill: rgba(52, 152, 219, 1); 
        }

        .hexagon[data-note-name^="G"]:not([data-note-name*="#"]) { 
            fill: rgba(155, 89, 182, 1); 
        }

        .hexagon[data-note-name^="A"]:not([data-note-name*="#"]) { 
            fill: rgba(230, 126, 34, 1); 
        }

        .hexagon[data-note-name^="B"] { 
            fill: rgba(26, 188, 156, 1); 
        }

        /* 
          Sharp Note Colors: A much darker mix of the surrounding natural notes.
          The active state uses a slightly lighter, but still dark, shade.
        */
        .hexagon[data-note-name*="C#"] { 
            /* Dark mix of C and D */
            fill: rgba(100, 65, 30, 1); 
        }
        .hexagon[data-note-name*="D#"] { 
            /* Dark mix of D and E */
            fill: rgba(80, 95, 45, 1); 
        }
        .hexagon[data-note-name*="F#"] { 
            /* Dark mix of F and G */
            fill: rgba(65, 60, 95, 1); 
        }
        .hexagon[data-note-name*="G#"] { 
            /* Dark mix of G and A */
            fill: rgba(95, 65, 75, 1); 
        }
        .hexagon[data-note-name*="A#"] { 
            /* Dark mix of A and B */
            fill: rgba(65, 85, 75, 1); 
        }

        /* Simple active state - just a brighter color */
        .hexagon[data-note-name^="C"]:not([data-note-name*="#"]).active { 
            fill: rgba(255, 120, 120, 1); 
        }

        .hexagon[data-note-name^="D"]:not([data-note-name*="#"]).active { 
            fill: rgba(250, 220, 120, 1); 
        }

        .hexagon[data-note-name^="E"].active { 
            fill: rgba(80, 230, 110, 1); 
        }

        .hexagon[data-note-name^="F"]:not([data-note-name*="#"]).active { 
            fill: rgba(100, 210, 250, 1); 
        }

        .hexagon[data-note-name^="G"]:not([data-note-name*="#"]).active { 
            fill: rgba(185, 130, 210, 1); 
        }

        .hexagon[data-note-name^="A"]:not([data-note-name*="#"]).active { 
            fill: rgba(250, 160, 50, 1); 
        }

        .hexagon[data-note-name^="B"].active { 
            fill: rgba(80, 210, 190, 1); 
        }

        /* Active states for sharp notes */
        .hexagon[data-note-name*="C#"].active { 
            /* Lighter, but still dark, mix of C and D */
            fill: rgba(140, 95, 50, 1); 
        }
        .hexagon[data-note-name*="D#"].active { 
            /* Lighter, but still dark, mix of D and E */
            fill: rgba(110, 125, 65, 1); 
        }
        .hexagon[data-note-name*="F#"].active { 
            /* Lighter, but still dark, mix of F and G */
            fill: rgba(85, 80, 115, 1); 
        }
        .hexagon[data-note-name*="G#"].active { 
            /* Lighter, but still dark, mix of G and A */
            fill: rgba(115, 85, 95, 1); 
        }
        .hexagon[data-note-name*="A#"].active { 
            /* Lighter, but still dark, mix of A and B */
            fill: rgba(85, 105, 95, 1); 
        }
        
        /* --- SVG Piano Styling --- */
        .piano-svg {
            display: block;
            transform: rotate(0deg);
            transition: transform 0.3s ease;
            width: 100%;
            height: 100%;
        }

        /* Rotate the hexboard in portrait mode */
        @media screen and (orientation: portrait) {
            .piano-svg {
                transform: rotate(90deg);
                max-width: 100vh;
                max-height: 100vw;
            }
        }

        /* Alternative approach using aspect ratio instead of orientation */
        @media screen and (max-aspect-ratio: 1/1) {
            .piano-svg {
                transform: rotate(90deg);
                max-width: 100vh;
                max-height: 100vw;
            }
        }

        /* Pulse animation for recording button */
        @keyframes pulse {
            0% {
                box-shadow: 0 0 0 0 rgba(255, 65, 54, 0.7);
            }
            70% {
                box-shadow: 0 0 0 10px rgba(255, 65, 54, 0);
            }
            100% {
                box-shadow: 0 0 0 0 rgba(255, 65, 54, 0);
            }
        }

        /* Mobile responsiveness for panel */
        @media screen and (max-width: 480px) {
            .overlay-panel {
                width: 90%;
                height: 40%;
            }
        }
    </style>
    <script type="text/javascript">
        document.addEventListener('DOMContentLoaded', function() {
            var DEBUG = false;
        
            // --- DOM ELEMENTS ---
            var hexboard = document.querySelector('.hexboard');
            var recordButton = document.getElementById('record-button');
            var playButton = document.getElementById('play-button');
            var playIcon = document.getElementById('play-icon');
            var stopIcon = document.getElementById('stop-icon');
            var waveTypeSelect = document.getElementById('wave-type');
            var volumeSlider = document.getElementById('volume-slider');
            var fullscreenButton = document.getElementById('fullscreen-button');
            var fullscreenEnterIcon = document.getElementById('fullscreen-enter-icon');
            var fullscreenExitIcon = document.getElementById('fullscreen-exit-icon');
            var overlayPanel = document.getElementById('overlay-panel');
            var panelCloseBtn = document.getElementById('panel-close-btn');
            var panelContent = document.getElementById('panel-content');
            var exportButton = document.getElementById('export-button');
            var importButton = document.getElementById('import-button');
            var fileInput = document.getElementById('file-input');

            // --- AUDIO SETUP ---
            var AudioContext = window.AudioContext || window.webkitAudioContext;
            var audioContext;
            var mainGainNode;
            var activeOscillators = {};
            var audioSupported = true;
            var audioInitialized = false;
            var firstUserInteraction = false;

            // --- STATE MANAGEMENT ---
            var isRecording = false;
            var isPlaying = false;
            var recordingStartTime;
            var recordedMelody = [
                { note: 'C5', freq: 523.251, time: 0, duration: 300 },
                { note: 'D5', freq: 587.330, time: 400, duration: 300 },
                { note: 'E5', freq: 659.255, time: 800, duration: 300 },
                { note: 'F5', freq: 698.456, time: 1200, duration: 300 },
                { note: 'A5', freq: 880.000, time: 1600, duration: 600 },
                { note: 'G5', freq: 783.991, time: 2200, duration: 600 },
                
                { note: 'A5', freq: 880.000, time: 3200, duration: 600 },
                { note: 'G5', freq: 783.991, time: 3800, duration: 300 },
                { note: 'F5', freq: 698.456, time: 4100, duration: 300 },
                { note: 'E5', freq: 659.255, time: 4400, duration: 600 },
                { note: 'G5', freq: 783.991, time: 5000, duration: 600 },
                { note: 'D5', freq: 587.330, time: 5600, duration: 600 },
            ];
            var playbackTimeouts = [];
            var recordingActiveNotes = {};
            var notesByPointerId = {};
            var firstNoteTime = null;
            var isDragging = false;
            var currentMouseNote = null;

            // Panel state
            var longPressTimer = null;
            var longPressDelay = 500; // milliseconds
            var panelOpen = false;

            // --- NOTE DATA (Wicki-Hayden inspired layout) ---
            var noteLayout = [
                // Octave 1
                { key: '', note: 'C1', freq: 32.703, type: 'white' },
                { key: '', note: 'C#1', freq: 34.648, type: 'black' },
                { key: '', note: 'D1', freq: 36.708, type: 'white' },
                { key: '', note: 'D#1', freq: 38.891, type: 'black' },
                { key: '', note: 'E1', freq: 41.203, type: 'white' },
                { key: '', note: 'F1', freq: 43.654, type: 'white' },
                { key: '', note: 'F#1', freq: 46.249, type: 'black' },
                { key: '', note: 'G1', freq: 49.000, type: 'white' },
                { key: '', note: 'G#1', freq: 51.913, type: 'black' },
                { key: '', note: 'A1', freq: 55.000, type: 'white' },
                { key: '', note: 'A#1', freq: 58.270, type: 'black' },
                { key: '', note: 'B1', freq: 61.735, type: 'white' },

                // Octave 2
                { key: '', note: 'C2', freq: 65.406, type: 'white' },
                { key: '', note: 'C#2', freq: 69.296, type: 'black' },
                { key: '', note: 'D2', freq: 73.416, type: 'white' },
                { key: '', note: 'D#2', freq: 77.782, type: 'black' },
                { key: '', note: 'E2', freq: 82.407, type: 'white' },
                { key: '', note: 'F2', freq: 87.307, type: 'white' },
                { key: '', note: 'F#2', freq: 92.499, type: 'black' },
                { key: '', note: 'G2', freq: 98.000, type: 'white' },
                { key: '', note: 'G#2', freq: 103.826, type: 'black' },
                { key: '', note: 'A2', freq: 110.000, type: 'white' },
                { key: '', note: 'A#2', freq: 116.541, type: 'black' },
                { key: '', note: 'B2', freq: 123.471, type: 'white' },
                
                // Octave 3
                { key: 'z', note: 'C3', freq: 130.813, type: 'white' },
                { key: '^z', note: 'C#3', freq: 138.591, type: 'black' },
                { key: 'x', note: 'D3', freq: 146.832, type: 'white' },
                { key: '^x', note: 'D#3', freq: 155.563, type: 'black' },
                { key: 'c', note: 'E3', freq: 164.814, type: 'white' },
                { key: 'v', note: 'F3', freq: 174.614, type: 'white' },
                { key: '^v', note: 'F#3', freq: 184.997, type: 'black' },
                { key: 'b', note: 'G3', freq: 196.000, type: 'white' },
                { key: '^b', note: 'G#3', freq: 207.652, type: 'black' },
                { key: 'n', note: 'A3', freq: 220.000, type: 'white' },
                { key: '^n', note: 'A#3', freq: 233.082, type: 'black' },
                { key: 'm', note: 'B3', freq: 246.942, type: 'white' },

                // Octave 4 (Middle C is C4)
                { key: 'a', note: 'C4', freq: 261.626, type: 'white' },
                { key: '^a', note: 'C#4', freq: 277.183, type: 'black' },
                { key: 's', note: 'D4', freq: 293.665, type: 'white' },
                { key: '^s', note: 'D#4', freq: 311.127, type: 'black' },
                { key: 'd', note: 'E4', freq: 329.628, type: 'white' },
                { key: 'f', note: 'F4', freq: 349.228, type: 'white' },
                { key: '^f', note: 'F#4', freq: 369.994, type: 'black' },
                { key: 'g', note: 'G4', freq: 392.000, type: 'white' },
                { key: '^g', note: 'G#4', freq: 415.305, type: 'black' },
                { key: 'h', note: 'A4', freq: 440.000, type: 'white' },
                { key: '^h', note: 'A#4', freq: 466.164, type: 'black' },
                { key: 'j', note: 'B4', freq: 493.883, type: 'white' },

                // Octave 5
                { key: 'q', note: 'C5', freq: 523.251, type: 'white' },
                { key: '^q', note: 'C#5', freq: 554.365, type: 'black' },
                { key: 'w', note: 'D5', freq: 587.330, type: 'white' },
                { key: '^w', note: 'D#5', freq: 622.254, type: 'black' },
                { key: 'e', note: 'E5', freq: 659.255, type: 'white' },
                { key: 'r', note: 'F5', freq: 698.456, type: 'white' },
                { key: '^r', note: 'F#5', freq: 739.989, type: 'black' },
                { key: 't', note: 'G5', freq: 783.991, type: 'white' },
                { key: '^t', note: 'G#5', freq: 830.609, type: 'black' },
                { key: 'y', note: 'A5', freq: 880.000, type: 'white' },
                { key: '^y', note: 'A#5', freq: 932.328, type: 'black' },
                { key: 'u', note: 'B5', freq: 987.767, type: 'black' },

                // Octave 6
                { key: '1', note: 'C6', freq: 1046.502, type: 'white' },
                { key: '', note: 'C#6', freq: 1108.731, type: 'black' },
                { key: '2', note: 'D6', freq: 1174.659, type: 'white' },
                { key: '', note: 'D#6', freq: 1244.508, type: 'black' },
                { key: '3', note: 'E6', freq: 1318.510, type: 'white' },
                { key: '4', note: 'F6', freq: 1396.913, type: 'white' },
                { key: '', note: 'F#6', freq: 1479.978, type: 'black' },
                { key: '5', note: 'G6', freq: 1567.982, type: 'white' },
                { key: '', note: 'G#6', freq: 1661.219, type: 'black' },
                { key: '6', note: 'A6', freq: 1760.000, type: 'white' },
                { key: '', note: 'A#6', freq: 1864.655, type: 'black' },
                { key: '7', note: 'B6', freq: 1975.533, type: 'white' },

                // Octave 7
                { key: '', note: 'C7', freq: 2093.005, type: 'white' },
                { key: '', note: 'C#7', freq: 2217.461, type: 'black' },
                { key: '', note: 'D7', freq: 2349.318, type: 'white' },
                { key: '', note: 'D#7', freq: 2489.016, type: 'black' },
                { key: '', note: 'E7', freq: 2637.020, type: 'white' },
                { key: '', note: 'F7', freq: 2793.826, type: 'white' },
                { key: '', note: 'F#7', freq: 2959.955, type: 'black' },
                { key: '', note: 'G7', freq: 3135.964, type: 'white' },
                { key: '', note: 'G#7', freq: 3322.438, type: 'black' },
                { key: '', note: 'A7', freq: 3520.000, type: 'white' },
                { key: '', note: 'A#7', freq: 3729.310, type: 'black' },
                { key: '', note: 'B7', freq: 3951.066, type: 'white' }
            ];
                    
            var noteRows = [
                noteLayout.slice(0, 12),   // C1 to B1
                noteLayout.slice(12, 24),  // C2 to B2
                noteLayout.slice(24, 36),  // C3 to B3
                noteLayout.slice(36, 48),  // C4 to B4
                noteLayout.slice(48, 60),  // C5 to B5
                noteLayout.slice(60, 72),  // C6 to B6
                noteLayout.slice(72, 84),  // C7 to B7
            ];

            var notesByKey = {};
            var notesByNoteName = {};

            // --- INITIALIZATION ---
            function init() {
                createPiano();
                addEventListeners();
                
                // Try to initialize audio context on page load
                tryInitAudioContext();
                
                // Add a one-time event listener for any user interaction
                function handleFirstInteraction() {
                    if (!firstUserInteraction) {
                        firstUserInteraction = true;
                        if (!audioInitialized) {
                            initAudioContext();
                        }
                        // Remove this listener after first interaction
                        document.removeEventListener('click', handleFirstInteraction);
                        document.removeEventListener('keydown', handleFirstInteraction);
                        document.removeEventListener('touchstart', handleFirstInteraction);
                    }
                }
                
                document.addEventListener('click', handleFirstInteraction);
                document.addEventListener('keydown', handleFirstInteraction);
                document.addEventListener('touchstart', handleFirstInteraction);
            }

            function tryInitAudioContext() {
                if (!AudioContext) {
                    console.error("Web Audio API is not supported in this browser");
                    audioSupported = false;
                    return;
                }
                
                try {
                    // Try to create audio context
                    audioContext = new AudioContext();
                    
                    // If it's not suspended, we can fully initialize
                    if (audioContext.state !== 'suspended') {
                        completeAudioContextInit();
                    } else {
                        // If suspended, we'll wait for user interaction
                        if(DEBUG) {
                            console.log("Audio context created but suspended, waiting for user interaction");
                        }
                    }
                } catch (e) {
                    console.error("Error creating audio context:", e);
                    audioSupported = false;
                }
            }

            function initAudioContext() {
                if (!AudioContext) {
                    console.error("Web Audio API is not supported in this browser");
                    audioSupported = false;
                    return;
                }
                
                if (audioInitialized) {
                    if(DEBUG) {
                        console.log("Audio context already initialized");
                    }
                    return;
                }
                
                try {
                    // Create or get existing audio context
                    if (!audioContext) {
                        audioContext = new AudioContext();
                    }
                    
                    completeAudioContextInit();
                    
                    // Resume the context if it's suspended
                    if (audioContext.state === 'suspended') {
                        audioContext.resume().then(function() {
                            if(DEBUG) {
                                console.log("Audio context resumed successfully");
                                console.log("Audio context state after resume:", audioContext.state);
                            }
                        }).catch(function(e) {
                            console.error("Error resuming audio context:", e);
                        });
                    }
                } catch (e) {
                    console.error("Error initializing audio context:", e);
                    audioSupported = false;
                }
            }
            
            function completeAudioContextInit() {
                mainGainNode = audioContext.createGain();
                mainGainNode.gain.value = volumeSlider.value;
                mainGainNode.connect(audioContext.destination);
                audioInitialized = true;
                
                if(DEBUG) {
                    console.log("Audio context initialized successfully");
                    console.log("Audio context state:", audioContext.state);
                }
                
                // Handle state changes
                audioContext.addEventListener('statechange', function() {
                    if(DEBUG) {
                        console.log("Audio context state changed to:", audioContext.state);
                    }
                    
                    // If the context is suspended, try to resume it
                    if (audioContext.state === 'suspended') {
                        audioContext.resume().then(function() {
                            if(DEBUG) {
                                console.log("Audio context resumed after state change");
                            }
                        }).catch(function(e) {
                            console.error("Error resuming audio context after state change:", e);
                        });
                    }
                });
            }
            
            function ensureAudioContextResumed() {
                if (!audioContext || !audioInitialized) {
                    console.error("Audio context is not initialized");
                    return false;
                }
                
                if (audioContext.state === 'suspended') {
                    audioContext.resume().then(function() {
                        if(DEBUG) {
                            console.log("Audio context resumed successfully");
                        }
                    }).catch(function(e) {
                        console.error("Error resuming audio context:", e);
                    });
                    return false;
                }
                
                return true;
            }

            function createPiano() {
                // Create main SVG container
                var svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
                svg.setAttribute('class', 'piano-svg');
                
                // Hexagon dimensions for proper tiling (pointy-top orientation)
                var hexRadius = 50; // Radius from center to any vertex
                
                // For pointy-top hexagons:
                // Width = 2 * radius
                // Height = sqrt(3) * radius
                var hexWidth = hexRadius * 2;
                var hexHeight = Math.sqrt(3) * hexRadius;
                
                // CORRECTED SPACING FOR PROPER TILING:
                // Horizontal spacing between centers is 1.5 * radius
                var horizontalSpacing = hexRadius * 1.75;
                // Vertical spacing between rows is the full height
                var verticalSpacing = hexHeight * 0.85;
                
                // Calculate total width and height with proper spacing
                var maxRowLength = Math.max(...noteRows.map(row => row.length));
                
                // For width: (maxRowLength-1) * spacing + hexWidth + offset for odd rows
                // The offset accounts for the half-spacing shift in alternating rows
                var totalWidth = (maxRowLength - 1) * horizontalSpacing + hexWidth + (horizontalSpacing / 2);
                
                // For height: (noteRows.length-1) * spacing + hexHeight
                // This properly accounts for the spacing between rows
                var totalHeight = (noteRows.length - 1) * verticalSpacing + hexHeight;
                
                // Set SVG dimensions
                svg.setAttribute('width', "100%");
                svg.setAttribute('height', "100%");
                svg.setAttribute('viewBox', '0 0 ' + totalWidth + ' ' + totalHeight);
                
                // Create hexagon points (pointy-top orientation)
                function getHexagonPoints(cx, cy, radius) {
                    var points = [];
                    // Start at top point and go clockwise
                    for (var i = 0; i < 6; i++) {
                        // 30°, 90°, 150°, 210°, 270°, 330° for pointy-top
                        var angle = (Math.PI / 3) * i - Math.PI / 2;
                        var x = cx + radius * Math.cos(angle);
                        var y = cy + radius * Math.sin(angle);
                        points.push(x + ',' + y);
                    }
                    return points.join(' ');
                }
                
                // Create hexagons for each note
                for (var i = 0; i < noteRows.length; i++) {
                    var rowData = noteRows[i];
                    
                    // Calculate row offset for hexagonal tiling
                    var rowOffsetX = (i % 2 === 1) ? horizontalSpacing / 2 : 0;
                    
                    var rowOffsetY = i * verticalSpacing;
                    
                    for (var j = 0; j < rowData.length; j++) {
                        var noteData = rowData[j];
                        
                        // Calculate center position for this hexagon
                        // FIX: Position the first hexagon at hexRadius, then add spacing for subsequent ones
                        var cx = rowOffsetX + hexRadius + (j * horizontalSpacing);
                        var cy = rowOffsetY + hexRadius;
                        
                        // Create group for hexagon and text
                        var g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                        g.setAttribute('class', 'hexagon-group');
                        
                        // Create hexagon polygon
                        var polygon = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
                        polygon.setAttribute('class', 'hexagon');
                        polygon.setAttribute('id', noteData.note);
                        polygon.setAttribute('points', getHexagonPoints(cx, cy, hexRadius));
                        polygon.setAttribute('data-key', noteData.key);
                        polygon.setAttribute('data-note', noteData.note);
                        polygon.setAttribute('data-freq', noteData.freq);
                        polygon.setAttribute('data-note-name', noteData.note.replace(/[0-9]/, ''));
                        
                        // Create note name text - positioned higher in the hexagon
                        var noteText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                        noteText.setAttribute('class', 'note-text');
                        noteText.setAttribute('x', cx);
                        noteText.setAttribute('y', cy - 12); // Moved up from center
                        noteText.textContent = noteData.note;
                        
                        // Create key label text - positioned lower in the hexagon
                        var keyText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                        keyText.setAttribute('class', 'note-key');
                        keyText.setAttribute('x', cx);
                        keyText.setAttribute('y', cy + 18); // Moved further down from center
                        keyText.textContent = noteData.key === 'Shift' ? '⇧' : noteData.key.toUpperCase();
                        
                        // Add elements to group
                        g.appendChild(polygon);
                        g.appendChild(noteText);
                        g.appendChild(keyText);
                        
                        // Add group to SVG
                        svg.appendChild(g);
                        
                        // Store references for event handling
                        notesByKey[noteData.key.toLowerCase()] = noteData;
                        notesByNoteName[noteData.note] = notesByNoteName[noteData.note] || [];
                        notesByNoteName[noteData.note].push(polygon);
                    }
                }
                
                // Add SVG to hexboard
                hexboard.appendChild(svg);
            }
            
            // --- AUDIO PLAYBACK ---
            function playNote(note, freq) {
                if (!audioSupported) {
                    console.warn("Audio is not supported in this browser");
                    return;
                }
                
                // Initialize audio context if not already done
                if (!audioInitialized) {
                    initAudioContext();
                }
                
                if (!audioContext || !audioInitialized) {
                    console.error("Audio context is not initialized");
                    return;
                }
                
                if (!ensureAudioContextResumed()) {
                    console.error("Audio context could not be resumed");
                    return;
                }
                
                // If note is already playing, stop it first
                if (activeOscillators[note]) {
                    stopNote(note);
                }

                try {
                    var now = audioContext.currentTime;
                    var gainValue = 0.7;

                    // Check if createOscillator is available
                    if (typeof audioContext.createOscillator !== 'function') {
                        throw new Error("createOscillator is not a function on audio context");
                    }

                    var oscillator = audioContext.createOscillator();
                    var gainNode = audioContext.createGain();

                    // Get wave type from the selected wave option
                    var selectedWave = document.querySelector('.wave-option.selected');
                    if (selectedWave) {
                        oscillator.type = selectedWave.getAttribute('data-wave-type');
                    } else {
                        // Default to sine if nothing is selected
                        oscillator.type = 'sine';
                    }
                    
                    // Round frequency to 3 decimal places
                    var roundedFreq = Math.round(freq * 1000) / 1000;
                    oscillator.frequency.setValueAtTime(roundedFreq, now);
                    
                    gainNode.gain.setValueAtTime(0, now);
                    gainNode.gain.linearRampToValueAtTime(gainValue, now + 0.02);
                    
                    oscillator.connect(gainNode);
                    gainNode.connect(mainGainNode);
                    oscillator.start(now);

                    activeOscillators[note] = { 
                        oscillator: oscillator, 
                        gainNode: gainNode
                    };
                    
                    if(DEBUG) {
                        console.log("Note started:", note, "Frequency:", roundedFreq);
                    }
                } catch (e) {
                    console.error("Error playing note:", e);
                }
            }
            
            function stopNote(note) {
                if (!audioSupported || !audioContext || !audioInitialized) return;
                
                if (!activeOscillators[note]) {
                    if(DEBUG) {
                        console.log("Note is not playing:", note);
                    }
                    return;
                }
                
                var oscillatorData = activeOscillators[note];
                
                try {
                    var oscillator = oscillatorData.oscillator;
                    var gainNode = oscillatorData.gainNode;
                    var now = audioContext.currentTime;
                    var releaseTime = 0.1; // Shorter release time for immediate stop
                    
                    gainNode.gain.cancelScheduledValues(now);
                    gainNode.gain.setValueAtTime(gainNode.gain.value, now);
                    gainNode.gain.linearRampToValueAtTime(0, now + releaseTime);

                    oscillator.stop(now + releaseTime + 0.01);
                    
                    // Immediately remove from active oscillators
                    delete activeOscillators[note];
                    
                    if(DEBUG) {
                        console.log("Note stopped:", note);
                    }
                } catch (e) {
                    console.error("Error stopping note:", e);
                    // Still remove from active oscillators even if stopping failed
                    delete activeOscillators[note];
                }
            }

            // --- VISUAL FEEDBACK ---
            function showKeyPress(note) {
                var hexes = notesByNoteName[note];
                if (hexes) {
                    for (var i = 0; i < hexes.length; i++) {
                        hexes[i].classList.add('active');
                    }
                }
            }

            function hideKeyPress(note) {
                var hexes = notesByNoteName[note];
                if (hexes) {
                    for (var i = 0; i < hexes.length; i++) {
                        hexes[i].classList.remove('active');
                    }
                }
            }

            // --- EVENT HANDLERS ---
            function handleNoteOn(noteData, pointerId) {
                if (!noteData) return;
                var note = noteData.note;
                var freq = noteData.freq;
                
                playNote(note, freq);
                showKeyPress(note);
                if (pointerId !== undefined) notesByPointerId[pointerId] = noteData;

                if (isRecording) {
                    var currentTime = performance.now();
                    
                    if (firstNoteTime === null) {
                        firstNoteTime = currentTime;
                    }
                    
                    recordingActiveNotes[note] = {
                        freq: freq,
                        startTime: currentTime
                    };
                }
            }

            function handleNoteOff(noteData, pointerId) {
                if (!noteData) return;
                var note = noteData.note;

                stopNote(note);
                hideKeyPress(note);
                if (pointerId !== undefined) delete notesByPointerId[pointerId];

                if (isRecording && recordingActiveNotes[note]) {
                    var noteStartData = recordingActiveNotes[note];
                    var noteEndTime = performance.now();
                    var durationMs = noteEndTime - noteStartData.startTime;

                    if (durationMs > 20) {
                        recordedMelody.push({
                            note: note,
                            freq: noteStartData.freq,
                            time: noteStartData.startTime - firstNoteTime,
                            duration: durationMs
                        });
                    }
                    delete recordingActiveNotes[note];
                }
            }

            function addEventListeners() {
                // Mouse events for SVG
                hexboard.addEventListener('mousedown', function(e) {
                    var hex = e.target;
                    if (hex.classList.contains('hexagon')) {
                        e.preventDefault();
                        isDragging = true;
                        var noteData = { 
                            note: hex.getAttribute('data-note'), 
                            freq: parseFloat(hex.getAttribute('data-freq')) 
                        };
                        currentMouseNote = noteData;
                        handleNoteOn(noteData);
                    }
                });

                document.addEventListener('mousemove', function(e) {
                    if (!isDragging) return;
                    
                    var hex = document.elementFromPoint(e.clientX, e.clientY);
                    if (hex && hex.classList.contains('hexagon')) {
                        var noteData = { 
                            note: hex.getAttribute('data-note'), 
                            freq: parseFloat(hex.getAttribute('data-freq')) 
                        };
                        
                        if (!currentMouseNote || currentMouseNote.note !== noteData.note) {
                            if (currentMouseNote) {
                                handleNoteOff(currentMouseNote);
                            }
                            handleNoteOn(noteData);
                            currentMouseNote = noteData;
                        }
                    }
                });

                document.addEventListener('mouseup', function(e) {
                    if (!isDragging) return;
                    
                    isDragging = false;
                    if (currentMouseNote) {
                        handleNoteOff(currentMouseNote);
                        currentMouseNote = null;
                    }
                    
                    // Stop ALL notes when mouse is released
                    for (var note in activeOscillators) {
                        stopNote(note);
                        hideKeyPress(note);
                    }
                });

                // Touch events for mobile
                hexboard.addEventListener('touchstart', function(e) {
                    var hex = e.target;
                    if (hex.classList.contains('hexagon')) {
                        e.preventDefault();
                        isDragging = true;
                        var touch = e.touches[0];
                        var noteData = { 
                            note: hex.getAttribute('data-note'), 
                            freq: parseFloat(hex.getAttribute('data-freq')) 
                        };
                        handleNoteOn(noteData, touch.identifier);
                    }
                });

                document.addEventListener('touchmove', function(e) {
                    if (!isDragging) return;
                    
                    var touch = e.touches[0];
                    var hex = document.elementFromPoint(touch.clientX, touch.clientY);
                    if (hex && hex.classList.contains('hexagon')) {
                        var noteData = { 
                            note: hex.getAttribute('data-note'), 
                            freq: parseFloat(hex.getAttribute('data-freq')) 
                        };
                        var currentNoteData = notesByPointerId[touch.identifier];
                        
                        if (!currentNoteData || currentNoteData.note !== noteData.note) {
                            if (currentNoteData) {
                                handleNoteOff(currentNoteData, touch.identifier);
                            }
                            handleNoteOn(noteData, touch.identifier);
                        }
                    }
                });

                document.addEventListener('touchend', function(e) {
                    if (!isDragging) return;
                    
                    isDragging = false;
                    for (var i = 0; i < e.changedTouches.length; i++) {
                        var touch = e.changedTouches[i];
                        var noteData = notesByPointerId[touch.identifier];
                        if (noteData) {
                            handleNoteOff(noteData, touch.identifier);
                        }
                    }
                    
                    // Stop ALL notes when touch ends
                    for (var note in activeOscillators) {
                        stopNote(note);
                        hideKeyPress(note);
                    }
                });

                window.addEventListener('keydown', function(e) {
                    if (e.repeat || e.metaKey || e.ctrlKey) return;
                    var key = e.key.toLowerCase();
                    
                    // Check if SHIFT is pressed and look for the corresponding modified key
                    if (e.shiftKey) {
                        var shiftKey = '^' + key;
                        var noteData = notesByKey[shiftKey];
                        if (noteData) {
                            e.preventDefault();
                            handleNoteOn(noteData);
                            return;
                        }
                    }
                    
                    // Fall back to regular key if no SHIFT modifier found
                    var noteData = notesByKey[key];
                    if (noteData) {
                        e.preventDefault();
                        handleNoteOn(noteData);
                    }
                });

                window.addEventListener('keyup', function(e) {
                    var key = e.key.toLowerCase();
                    
                    // Check if SHIFT is pressed and look for the corresponding modified key
                    if (e.shiftKey) {
                        var shiftKey = '^' + key;
                        var noteData = notesByKey[shiftKey];
                        if (noteData) {
                            e.preventDefault();
                            handleNoteOff(noteData);
                            return;
                        }
                    }
                    
                    // Fall back to regular key if no SHIFT modifier found
                    var noteData = notesByKey[key];
                    if (noteData) {
                        e.preventDefault();
                        handleNoteOff(noteData);
                    }
                });

                recordButton.addEventListener('click', toggleRecording);
                
                // Panel event listeners
                panelCloseBtn.addEventListener('click', closePanel);
                
                // Long press detection for play button
                playButton.addEventListener('mousedown', startLongPress);
                playButton.addEventListener('mouseup', endLongPress);
                playButton.addEventListener('mouseleave', cancelLongPress);
                playButton.addEventListener('touchstart', startLongPress);
                playButton.addEventListener('touchend', endLongPress);
                playButton.addEventListener('touchcancel', cancelLongPress);
                
                // Wave type selection
                var waveOptions = document.querySelectorAll('.wave-option');
                waveOptions.forEach(function(option) {
                    option.addEventListener('click', function() {
                        // Remove selected class from all options
                        waveOptions.forEach(function(opt) {
                            opt.classList.remove('selected');
                        });
                        
                        // Add selected class to clicked option
                        this.classList.add('selected');
                    });
                });
                
                // Set sine as default selected wave
                document.querySelector('.wave-option[data-wave-type="sine"]').classList.add('selected');
                
                // Other button listeners
                fullscreenButton.addEventListener('click', toggleFullscreen);
                volumeSlider.addEventListener('input', function(e) {
                    if (mainGainNode) mainGainNode.gain.value = e.target.value;
                });
                
                // Import/Export button listeners
                exportButton.addEventListener('click', exportMelody);
                importButton.addEventListener('click', function() {
                    fileInput.click();
                });
                
                fileInput.addEventListener('change', importMelody);
            }

            // --- PANEL FUNCTIONS ---
            function startLongPress(e) {
                e.preventDefault();
                longPressTimer = setTimeout(function() {
                    openPanel();
                    panelOpen = true;
                }, longPressDelay);
            }

            function endLongPress(e) {
                if (longPressTimer) {
                    clearTimeout(longPressTimer);
                    longPressTimer = null;
                }
                
                // Only trigger playback if panel didn't open
                if (!panelOpen) {
                    togglePlayback();
                }
                
                // Reset panelOpen flag
                setTimeout(function() {
                    panelOpen = false;
                }, 100);
            }

            function cancelLongPress(e) {
                if (longPressTimer) {
                    clearTimeout(longPressTimer);
                    longPressTimer = null;
                }
            }

            function openPanel() {
                overlayPanel.classList.add('active');
                longPressTimer = null;
                updatePanelContent();
            }

            function closePanel() {
                overlayPanel.classList.remove('active');
            }
            
            function updatePanelContent() {
                // Clear existing content
                panelContent.innerHTML = '';
                
                if (recordedMelody.length === 0) {
                    var emptyMessage = document.createElement('div');
                    emptyMessage.textContent = 'No melody recorded yet. Record a melody to see it here.';
                    emptyMessage.style.textAlign = 'center';
                    emptyMessage.style.padding = '20px';
                    panelContent.appendChild(emptyMessage);
                    return;
                }
                
                // Create header row
                var headerRow = document.createElement('div');
                headerRow.className = 'note-list-header';
                
                var headerNote = document.createElement('div');
                headerNote.className = 'note-name';
                headerNote.textContent = 'Note';
                
                var headerFreq = document.createElement('div');
                headerFreq.className = 'note-freq';
                headerFreq.textContent = 'Freq. (Hz)';
                
                var headerTime = document.createElement('div');
                headerTime.className = 'note-time';
                headerTime.textContent = 'Time (ms)';
                
                var headerDuration = document.createElement('div');
                headerDuration.className = 'note-duration';
                headerDuration.textContent = 'Duration (ms)';
                
                headerRow.appendChild(headerNote);
                headerRow.appendChild(headerFreq);
                headerRow.appendChild(headerTime);
                headerRow.appendChild(headerDuration);
                
                panelContent.appendChild(headerRow);
                
                // Add notes
                recordedMelody.forEach(function(note, index) {
                    var noteItem = document.createElement('div');
                    noteItem.className = 'note-item';
                    
                    var noteName = document.createElement('div');
                    noteName.className = 'note-name';
                    noteName.textContent = note.note;
                    
                    var noteFreq = document.createElement('div');
                    noteFreq.className = 'note-freq';
                    noteFreq.textContent = note.freq.toFixed(3);
                    
                    var noteTime = document.createElement('div');
                    noteTime.className = 'note-time';
                    noteTime.textContent = note.time.toFixed(0);
                    
                    var noteDuration = document.createElement('div');
                    noteDuration.className = 'note-duration';
                    noteDuration.textContent = note.duration.toFixed(0);
                    
                    noteItem.appendChild(noteName);
                    noteItem.appendChild(noteFreq);
                    noteItem.appendChild(noteTime);
                    noteItem.appendChild(noteDuration);
                    
                    panelContent.appendChild(noteItem);
                });
            }
            
            // --- IMPORT/EXPORT FUNCTIONS ---
            function exportMelody() {
                if (recordedMelody.length === 0) {
                    alert('No melody to export. Record a melody first.');
                    return;
                }
                
                var melodyData = {
                    name: 'Hexano Melody',
                    date: new Date().toISOString(),
                    notes: recordedMelody
                };
                
                var dataStr = JSON.stringify(melodyData, null, 2);
                var dataUri = 'data:application/json;charset=utf-8,'+ encodeURIComponent(dataStr);
                
                var exportFileDefaultName = 'melody.json';
                
                var linkElement = document.createElement('a');
                linkElement.setAttribute('href', dataUri);
                linkElement.setAttribute('download', exportFileDefaultName);
                linkElement.click();
            }
            
            function importMelody(event) {
                var file = event.target.files[0];
                if (!file) return;
                
                var reader = new FileReader();
                reader.onload = function(e) {
                    try {
                        var melodyData = JSON.parse(e.target.result);
                        
                        // Validate the imported data
                        if (!melodyData.notes || !Array.isArray(melodyData.notes)) {
                            throw new Error('Invalid melody file format');
                        }
                        
                        // Update the recorded melody
                        recordedMelody = melodyData.notes;
                        
                        // Update the panel content
                        updatePanelContent();
                        
                        alert('Melody imported successfully!');
                    } catch (error) {
                        alert('Error importing melody: ' + error.message);
                    }
                };
                
                reader.readAsText(file);
                
                // Reset the file input value to allow importing the same file again
                event.target.value = '';
            }

            // --- CONTROL BAR LOGIC ---
            function toggleRecording() {
                if (!audioSupported) {
                    alert("Audio recording is not supported in this browser");
                    return;
                }
                
                isRecording = !isRecording;
                if (isRecording) {
                    if (isPlaying) stopPlayback();
                    recordButton.className = 'recording';
                    recordedMelody = [];
                    recordingActiveNotes = {};
                    recordingStartTime = performance.now();
                    firstNoteTime = null;
                } else {
                    recordButton.className = '';
                    var recordingStopTime = performance.now();
                    
                    for (var note in recordingActiveNotes) {
                        if (recordingActiveNotes.hasOwnProperty(note)) {
                            var noteStartData = recordingActiveNotes[note];
                            recordedMelody.push({
                                note: note,
                                freq: noteStartData.freq,
                                time: noteStartData.startTime - firstNoteTime,
                                duration: recordingStopTime - noteStartData.startTime
                            });
                        }
                    }
                    recordingActiveNotes = {};

                    if (recordedMelody.length > 0) {
                        generateWav();
                    }
                }
            }
            
            function togglePlayback() {
                if (!audioSupported) {
                    alert("Audio playback is not supported in this browser");
                    return;
                }
                
                if (isPlaying) stopPlayback();
                else if (recordedMelody.length > 0) startPlayback();
            }
            
            function startPlayback() {
                if (isRecording) toggleRecording();
        
                isPlaying = true;
                playIcon.style.display = 'none';
                stopIcon.style.display = 'block';
                
                console.log(recordedMelody);

                // Ensure audio context is resumed before starting playback
                if (!ensureAudioContextResumed()) {
                    console.error("Cannot start playback: audio context could not be resumed");
                    stopPlayback();
                    return;
                }

                for (var i = 0; i < recordedMelody.length; i++) {
                    var noteEvent = recordedMelody[i];
                    var noteData = { note: noteEvent.note, freq: noteEvent.freq };
                    
                    (function(note, time, duration) {
                        var playTimeout = setTimeout(function() { 
                            // Double-check audio context before playing each note
                            if (ensureAudioContextResumed()) {
                                handleNoteOn(note); 
                            } else {
                                console.error("Cannot play note: audio context could not be resumed");
                            }
                        }, time);
                        var stopTimeout = setTimeout(function() { 
                            handleNoteOff(note); 
                        }, time + duration);
                        playbackTimeouts.push(playTimeout, stopTimeout);
                    })(noteData, noteEvent.time, noteEvent.duration);
                }
                
                var totalDuration = recordedMelody.length > 0 ? 
                    Math.max.apply(Math, recordedMelody.map(function(n) { return n.time + n.duration; })) : 0;
                var finalTimeout = setTimeout(stopPlayback, totalDuration + 500);
                playbackTimeouts.push(finalTimeout);
            }

            function stopPlayback() {
                isPlaying = false;
                playIcon.style.display = 'block';
                stopIcon.style.display = 'none';
                
                for (var i = 0; i < playbackTimeouts.length; i++) {
                    clearTimeout(playbackTimeouts[i]);
                }
                playbackTimeouts = [];
                
                // Stop all notes when playback stops
                for (var note in activeOscillators) {
                    stopNote(note);
                    hideKeyPress(note);
                }
            }
            
            function toggleFullscreen() {
                if (!document.fullscreenElement) {
                    if (document.documentElement.requestFullscreen) {
                        document.documentElement.requestFullscreen();
                    } else if (document.documentElement.webkitRequestFullscreen) {
                        document.documentElement.webkitRequestFullscreen();
                    } else if (document.documentElement.mozRequestFullScreen) {
                        document.documentElement.mozRequestFullScreen();
                    } else if (document.documentElement.msRequestFullscreen) {
                        document.documentElement.msRequestFullscreen();
                    }
                } else {
                    if (document.exitFullscreen) {
                        document.exitFullscreen();
                    } else if (document.webkitExitFullscreen) {
                        document.webkitExitFullscreen();
                    } else if (document.mozCancelFullScreen) {
                        document.mozCancelFullScreen();
                    } else if (document.msExitFullscreen) {
                        document.msExitFullscreen();
                    }
                }
            }
            
            document.addEventListener('fullscreenchange', function() {
                var isFullscreen = !!document.fullscreenElement;
                fullscreenEnterIcon.style.display = isFullscreen ? 'none' : 'block';
                fullscreenExitIcon.style.display = isFullscreen ? 'block' : 'none';
            });
            
            document.addEventListener('webkitfullscreenchange', function() {
                var isFullscreen = !!document.webkitFullscreenElement;
                fullscreenEnterIcon.style.display = isFullscreen ? 'none' : 'block';
                fullscreenExitIcon.style.display = isFullscreen ? 'block' : 'none';
            });
            
            document.addEventListener('mozfullscreenchange', function() {
                var isFullscreen = !!document.mozFullScreenElement;
                fullscreenEnterIcon.style.display = isFullscreen ? 'none' : 'block';
                fullscreenExitIcon.style.display = isFullscreen ? 'block' : 'none';
            });
            
            document.addEventListener('MSFullscreenChange', function() {
                var isFullscreen = !!document.msFullscreenElement;
                fullscreenEnterIcon.style.display = isFullscreen ? 'none' : 'block';
                fullscreenExitIcon.style.display = isFullscreen ? 'block' : 'none';
            });
            
            // --- WAV EXPORT ---
            function generateWav() {
                if (recordedMelody.length === 0 || !audioSupported) return;

                var totalMs = Math.max.apply(Math, recordedMelody.map(function(note) { 
                    return note.time + note.duration; 
                }));
                var durationSec = (totalMs / 1000) + 0.5;
                
                try {
                    var offlineContext = new OfflineAudioContext(1, Math.ceil(44100 * durationSec), 44100);
                    var offlineGainNode = offlineContext.createGain();
                    offlineGainNode.gain.value = volumeSlider.value;
                    offlineGainNode.connect(offlineContext.destination);

                    // Get wave type from the selected wave option
                    var selectedWave = document.querySelector('.wave-option.selected');
                    var waveType = selectedWave ? selectedWave.getAttribute('data-wave-type') : 'sine';

                    for (var i = 0; i < recordedMelody.length; i++) {
                        var note = recordedMelody[i];
                        var startTime = note.time / 1000;
                        var noteDuration = note.duration / 1000;
                        if (noteDuration <= 0.01) continue;

                        var attackTime = 0.02;
                        var releaseTime = Math.min(noteDuration * 0.5, 0.2);

                        var oscillator = offlineContext.createOscillator();
                        var gainNode = offlineContext.createGain();
                        
                        oscillator.type = waveType;
                        // Round frequency to 3 decimal places
                        var roundedFreq = Math.round(note.freq * 1000) / 1000;
                        oscillator.frequency.value = roundedFreq;

                        gainNode.gain.setValueAtTime(0, startTime);
                        gainNode.gain.linearRampToValueAtTime(0.7, startTime + attackTime);
                        gainNode.gain.linearRampToValueAtTime(0, startTime + noteDuration);

                        oscillator.connect(gainNode);
                        gainNode.connect(offlineGainNode);
                        oscillator.start(startTime);
                        oscillator.stop(startTime + noteDuration + 0.05);
                    }

                    offlineContext.startRendering().then(function(renderedBuffer) {
                        var wavBlob = bufferToWave(renderedBuffer);
                        downloadBlob(wavBlob, 'hexagon.wav');
                    }).catch(function(e) {
                        console.error("Failed to render WAV:", e);
                        alert("Sorry, there was an error creating the audio file.");
                    });
                } catch (e) {
                    console.error("Error generating WAV:", e);
                    alert("Sorry, there was an error creating the audio file.");
                }
            }

            function downloadBlob(blob, filename) {
                var url = URL.createObjectURL(blob);
                var a = document.createElement('a');
                a.style.display = 'none';
                a.href = url;
                a.download = filename;
                document.body.appendChild(a);
                a.click();
                URL.revokeObjectURL(url);
                a.parentNode.removeChild(a);
            }

            function bufferToWave(abuffer) {
                var numOfChan = abuffer.numberOfChannels,
                    len = abuffer.length * numOfChan * 2 + 44,
                    buffer = new ArrayBuffer(len),
                    view = new DataView(buffer),
                    channels = [],
                    i, sample, offset = 0, pos = 0;
                
                // Write WAVE header
                setUint32(0x46464952); // "RIFF"
                setUint32(len - 8); // file length - 8
                setUint32(0x45564157); // "WAVE"
                setUint32(0x20746d66); // "fmt " chunk
                setUint32(16); // length = 16
                setUint16(1); // PCM
                setUint16(numOfChan);
                setUint32(abuffer.sampleRate);
                setUint32(abuffer.sampleRate * 4); // avg. bytes/sec
                setUint16(4); // block-align
                setUint16(16); // 16-bit
                
                // Write data chunk
                setUint32(0x61746164); // "data" - chunk
                setUint32(len - pos - 4); // chunk length
                
                // Write interleaved data
                for (i = 0; i < abuffer.numberOfChannels; i++)
                    channels.push(abuffer.getChannelData(i));
                
                while (pos < len - 44) {
                    for (i = 0; i < numOfChan; i++) {
                        sample = Math.max(-1, Math.min(1, channels[i][offset]));
                        sample = sample < 0 ? sample * 0x8000 : sample * 0x7FFF;
                        view.setInt16(pos, sample, true);
                        pos += 2;
                    }
                    offset++;
                }
                
                return new Blob([buffer], { type: "audio/wav" });
                
                function setUint16(data) {
                    view.setUint16(pos, data, true);
                    pos += 2;
                }
                
                function setUint32(data) {
                    view.setUint32(pos, data, true);
                    pos += 4;
                }
            }

            init();
        });
    </script>
</head>
<body>
    <div class="app-container">
        <div class="control-bar">
            <button id="record-button" title="Record / Stop and Save WAV">
                <div id="record-indicator"></div>
            </button>
            <button id="play-button" title="Play / Stop Melody">
                <svg id="play-icon" class="icon" viewBox="0 0 24 24">
                    <path d="M8 5v14l11-7z"/>
                </svg>
                <svg id="stop-icon" class="icon" viewBox="0 0 24 24" style="display: none;">
                    <path d="M6 6h12v12H6z"/>
                </svg>
            </button>

            <div class="wave-selector">
                <div class="wave-option" data-wave-type="sine" title="Sine Wave">
                    <svg viewBox="0 0 60 30">
                        <path d="M0,15 Q7.5,5 15,15 T30,15 T45,15 T60,15" />
                    </svg>
                </div>
                <div class="wave-option" data-wave-type="square" title="Square Wave">
                    <svg viewBox="0 0 60 30">
                        <path d="M0,22 L0,8 L30,8 L30,22 L60,22" />
                    </svg>
                </div>
                <div class="wave-option" data-wave-type="sawtooth" title="Sawtooth Wave">
                    <svg viewBox="0 0 60 30">
                        <path d="M0,22 L30,8 L30,22 L60,8" />
                    </svg>
                </div>
                <div class="wave-option" data-wave-type="triangle" title="Triangle Wave">
                    <svg viewBox="0 0 60 30">
                        <path d="M0,22 L15,8 L30,22 L45,8 L60,22" />
                    </svg>
                </div>
            </div>

            <input type="range" id="volume-slider" min="0" max="1" value="0.5" step="0.01" title="Volume">

            <div style="display: inline-block; width: 50px;"></div> <!-- Spacer -->

            <button id="fullscreen-button" title="Toggle Fullscreen">
                <svg id="fullscreen-enter-icon" class="icon" viewBox="0 0 24 24">
                    <path d="M7 14H5v5h5v-2H7v-3zm-2-4h2V7h3V5H5v5zm12 7h-3v2h5v-5h-2v3zM14 5v2h3v3h2V5h-5z"/>
                </svg>
                <svg id="fullscreen-exit-icon" class="icon" viewBox="0 0 24 24" style="display:none;">
                    <path d="M5 16h3v3h2v-5H5v2zm3-8H5v2h5V5H8v3zm6 11h2v-3h3v-2h-5v5zm2-11V5h-2v5h5V8h-3z"/>
                </svg>
            </button>
        </div>
        <div class="hexboard">
            <!-- SVG piano will be generated here -->
        </div>
        
        <!-- Melody Panel -->
        <div id="overlay-panel" class="overlay-panel">
            <button id="panel-close-btn" class="close-btn">×</button>
            <div class="panel-header">
                <h2>Recorded Melody</h2>
            </div>
            <div id="panel-content" class="panel-content">
                <!-- Notes will be displayed here -->
            </div>
            <div class="panel-buttons">
                <button id="export-button" class="panel-button">Export JSON</button>
                <button id="import-button" class="panel-button">Import JSON</button>
                <input type="file" id="file-input" accept=".json" style="display: none;">
            </div>
        </div>
    </div>
</body>
</html>
