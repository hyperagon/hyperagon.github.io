<!DOCTYPE html>
<html lang="en">
<!--
Copyright (c) 2026 Hyperagon

Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
-->
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Hexano 6.9</title>
    <style type="text/css">
        /* --- Basic Setup & Theme --- */
        html, body {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            background-color: #1a1a1a;
            color: #e0e0e0;
            font-family: Courier, CourierNew, sans-serif;
            font-weight: bold;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
            -webkit-touch-callout: none;
        }

        /* --- Main Layout --- */
        .app-container {
            display: flex;
            flex-direction: column;
            width: 100%;
            height: 100%;
        }

        .hexboard-container {
            flex-grow: 1; /* This makes it fill the remaining vertical space */
            display: flex;
            justify-content: center;
            align-items: center;
            overflow: hidden;
            position: relative;
            width: 100%;
            height: 100%;
        }

        .hexboard {
            display: block;
            transform-origin: center center;
            transition: transform 0.3s ease;
        }

        /* --- Control Bar --- */
        .control-bar {
            flex-shrink: 0; /* Prevents the bar from shrinking */
            z-index: 10;    /* Keeps it on top */
            display: block;
            position: relative;
            padding: 10px 20px;
            background-color: #2a2a2a;
            border-bottom: 1px solid #000;
            text-align: center;
        }
        
        .control-bar button, .control-bar select {
            background: none;
            border: none;
            color: #e0e0e0;
            cursor: pointer;
            font-size: 16px;
            margin: 0 5px;
            vertical-align: middle;
        }

        .control-bar select {
            background-color: #333;
            border: 1px solid #555;
            padding: 5px;
        }

        .control-bar input[type="range"] {
            width: 100px;
            cursor: pointer;
            vertical-align: middle;
        }
        
        #record-button {
            width: 32px;
            height: 32px;
            border: 2px solid #e0e0e0;
            border-radius: 50%;
            display: inline-block;
            position: relative;
            transition: border-color 0.2s, box-shadow 0.3s;
        }

        #record-button.recording {
            border-color: #ff4136;
            animation: pulse 1.5s infinite;
        }

        #record-indicator {
            width: 18px;
            height: 18px;
            background-color: #ff4136;
            border-radius: 50%;
            position: absolute;
            top: 50%;
            left: 50%;
            margin-top: -9px;
            margin-left: -9px;
            transform: scale(0);
            transition: transform 0.2s ease-in-out;
        }

        #record-button.recording #record-indicator {
            transform: scale(1);
        }

        #play-button, #fullscreen-button, #instrument-button {
            width: 32px;
            height: 32px;
            padding: 0;
            display: inline-block;
            vertical-align: middle;
            position: relative;
        }

        .icon {
            width: 100%;
            height: 100%;
            fill: currentColor;
        }

        /* --- Instrument Selector --- */
        .instrument-selector {
            position: relative;
            display: inline-block;
        }

        .instrument-dropdown {
            position: absolute;
            top: 100%;
            left: 0;
            background-color: #333;
            border: 1px solid #555;
            border-radius: 5px;
            padding: 5px 0;
            margin-top: 5px;
            min-width: 150px;
            display: none;
            z-index: 100;
        }

        .instrument-dropdown.active {
            display: block;
        }

        .instrument-option {
            padding: 8px 15px;
            cursor: pointer;
            display: flex;
            align-items: center;
        }

        .instrument-option:hover {
            background-color: #444;
        }

        .instrument-option.selected {
            background-color: #4a4a4a;
        }

        .instrument-option .icon {
            width: 20px;
            height: 20px;
            margin-right: 10px;
        }

        /* --- Melody Panel --- */
        .overlay-panel {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 600px;
            height: 400px;
            background-color: #333;
            border: 2px solid #555;
            border-radius: 10px;
            z-index: 1000;
            display: none;
            box-shadow: 0 5px 25px rgba(0, 0, 0, 0.8);
            flex-direction: column;
            padding: 20px;
            box-sizing: border-box;
        }

        .overlay-panel.active {
            display: flex;
        }

        .overlay-panel .close-btn {
            position: absolute;
            top: 10px;
            right: 10px;
            width: 30px;
            height: 30px;
            background-color: #555;
            border: none;
            border-radius: 50%;
            color: #e0e0e0;
            font-size: 18px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .overlay-panel .close-btn:hover {
            background-color: #666;
        }

        .panel-header {
            text-align: center;
            margin-bottom: 10px;
        }

        .panel-header h2 {
            margin: 0;
            padding: 0;
        }

        .panel-content {
            flex-grow: 1;
            overflow-y: auto;
            background-color: #222;
            border-radius: 5px;
            padding: 10px;
            margin-bottom: 15px;
        }

        .note-list-header {
            display: flex;
            padding: 5px 10px;
            border-bottom: 2px solid #555;
            font-weight: bold;
            color: #e0e0e0;
        }

        .note-item {
            display: flex;
            padding: 5px 10px;
            border-bottom: 1px solid #444;
            align-items: center;
        }

        .note-item:last-child {
            border-bottom: none;
        }

        .note-name {
            font-weight: bold;
            flex: 1;
            text-align: center;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .note-freq {
            color: #aaa;
            flex: 1;
            text-align: center;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .note-time {
            color: #aaa;
            flex: 1;
            text-align: center;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .note-duration {
            color: #aaa;
            flex: 1;
            text-align: center;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .panel-buttons {
            display: grid;
            grid-template-columns: 1fr 1fr; /* Forces 2 columns */
            gap: 10px;
        }

        .panel-button {
            background-color: #444;
            border: 1px solid #666;
            border-radius: 5px;
            color: #e0e0e0;
            padding: 8px 15px;
            cursor: pointer;
            transition: background-color 0.2s;
            flex: 1;
            min-width: 120px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .panel-button:hover {
            background-color: #555;
        }

        /* --- Wave Type Selector --- */
        .wave-selector {
            display: inline-flex;
            margin: 0 5px;
            vertical-align: middle;
        }

        .wave-option {
            width: 60px;
            height: 30px;
            background-color: #333;
            border: 1px solid #555;
            margin: 0 2px;
            cursor: pointer;
            position: relative;
            transition: all 0.2s;
        }

        .wave-option:hover {
            background-color: #444;
        }

        .wave-option.selected {
            background-color: #555;
            border-color: #777;
        }

        .wave-option svg {
            width: 100%;
            height: 100%;
        }

        .wave-option path {
            stroke: #e0e0e0;
            stroke-width: 1.5;
            fill: none;
        }

        /* --- SVG Piano Styling --- */
        .piano-svg {
            display: block;
        }
        
        .hexagon {
            cursor: pointer;
            stroke: black;
            stroke-width: 1px;
            transition: fill 0.05s ease-in-out;
        }

        .note-text {
            fill: white;
            stroke: black;
            stroke-width: 1px;
            text-anchor: middle;
            font-size: 200%;
            font-weight: bold;
            pointer-events: none;
        }
        
        .note-key {
            fill: black;
            stroke: black;
            stroke-width: 1px;
            text-anchor: middle;
            font-size: 120%;
            font-weight: normal;
            pointer-events: none;
        }
        
        /* Note specific colors - SOLID OPAQUE COLORS */
        .hexagon[data-note-name^="C"]:not([data-note-name*="#"]) { 
            fill: rgba(231, 76, 60, 1);
        }

        .hexagon[data-note-name^="D"]:not([data-note-name*="#"]) { 
            fill: rgba(241, 196, 15, 1); 
        }

        .hexagon[data-note-name^="E"] { 
            fill: rgba(46, 204, 113, 1); 
        }

        .hexagon[data-note-name^="F"]:not([data-note-name*="#"]) { 
            fill: rgba(52, 152, 219, 1); 
        }

        .hexagon[data-note-name^="G"]:not([data-note-name*="#"]) { 
            fill: rgba(155, 89, 182, 1); 
        }

        .hexagon[data-note-name^="A"]:not([data-note-name*="#"]) { 
            fill: rgba(230, 126, 34, 1); 
        }

        .hexagon[data-note-name^="B"] { 
            fill: rgba(26, 188, 156, 1); 
        }

        /* 
          Sharp Note Colors: A much darker mix of surrounding natural notes.
          The active state uses a slightly lighter, but still dark, shade.
        */
        .hexagon[data-note-name*="C#"] { 
            /* Dark mix of C and D */
            fill: rgba(100, 65, 30, 1); 
        }
        .hexagon[data-note-name*="D#"] { 
            /* Dark mix of D and E */
            fill: rgba(80, 95, 45, 1); 
        }
        .hexagon[data-note-name*="F#"] { 
            /* Dark mix of F and G */
            fill: rgba(65, 60, 95, 1); 
        }
        .hexagon[data-note-name*="G#"] { 
            /* Dark mix of G and A */
            fill: rgba(95, 65, 75, 1); 
        }
        .hexagon[data-note-name*="A#"] { 
            /* Dark mix of A and B */
            fill: rgba(65, 85, 75, 1); 
        }

        /* Simple active state - just a brighter color */
        .hexagon[data-note-name^="C"]:not([data-note-name*="#"]).active { 
            fill: rgba(255, 120, 120, 1); 
        }

        .hexagon[data-note-name^="D"]:not([data-note-name*="#"]).active { 
            fill: rgba(250, 220, 120, 1); 
        }

        .hexagon[data-note-name^="E"].active { 
            fill: rgba(80, 230, 110, 1); 
        }

        .hexagon[data-note-name^="F"]:not([data-note-name*="#"]).active { 
            fill: rgba(100, 210, 250, 1); 
        }

        .hexagon[data-note-name^="G"]:not([data-note-name*="#"]).active { 
            fill: rgba(185, 130, 210, 1); 
        }

        .hexagon[data-note-name^="A"]:not([data-note-name*="#"]).active { 
            fill: rgba(250, 160, 50, 1); 
        }

        .hexagon[data-note-name^="B"].active { 
            fill: rgba(80, 210, 190, 1); 
        }

        /* Active states for sharp notes */
        .hexagon[data-note-name*="C#"].active { 
            /* Lighter, but still dark, mix of C and D */
            fill: rgba(140, 95, 50, 1); 
        }
        .hexagon[data-note-name*="D#"].active { 
            /* Lighter, but still dark, mix of D and E */
            fill: rgba(110, 125, 65, 1); 
        }
        .hexagon[data-note-name*="F#"].active { 
            /* Lighter, but still dark, mix of F and G */
            fill: rgba(85, 80, 115, 1); 
        }
        .hexagon[data-note-name*="G#"].active { 
            /* Lighter, but still dark, mix of G and A */
            fill: rgba(115, 85, 95, 1); 
        }
        .hexagon[data-note-name*="A#"].active { 
            /* Lighter, but still dark, mix of A and B */
            fill: rgba(85, 105, 95, 1); 
        }
        
        /* Pulse animation for recording button */
        @keyframes pulse {
            0% {
                box-shadow: 0 0 0 0 rgba(255, 65, 54, 0.7);
            }
            70% {
                box-shadow: 0 0 0 10px rgba(255, 65, 54, 0);
            }
            100% {
                box-shadow: 0 0 0 0 rgba(255, 65, 54, 0);
            }
        }

        /* Progress bar for audio conversion */
        .progress-container {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 300px;
            background-color: #333;
            border: 1px solid #555;
            border-radius: 5px;
            padding: 15px;
            z-index: 2000;
            display: none;
            box-shadow: 0 5px 25px rgba(0, 0, 0, 0.8);
        }

        .progress-container.active {
            display: block;
        }

        .progress-bar {
            width: 100%;
            height: 10px;
            background-color: #222;
            border-radius: 5px;
            margin-top: 10px;
            overflow: hidden;
        }

        .progress-fill {
            height: 100%;
            background-color: #4CAF50;
            background-color: #9bbc0f !important;
            
            width: 0%;
            transition: width 0.3s;
        }

        .progress-text {
            text-align: center;
            margin-bottom: 5px;
        }

        /* Game Boy instrument specific styles - ONLY BACKGROUND */
        .gameboy-theme {
            background-color: #9bbc0f !important;
        }

        /* Guitar instrument specific styles */
        .guitar-theme {
            background-color: #8B4513 !important;
        }

        /* SNES instrument specific styles */
        .snes-theme {
            background-color: #5D4E37 !important;
        }

        /* Drums instrument specific styles */
        .drums-theme {
            background-color: #3a3a3a !important;
        }
        
        .bell-theme {
            background-color: #D4AF37 !important; /* Metallic Gold */
        }
        
        .flute-theme {
            background-color: #A0522D !important; /* Sienna/Wood */
        }
        
        .violin-theme {
            background-color: #5D4037 !important; /* Dark Mahogany */
        }
        
        .ukulele-theme {
            background-color: #DEB887 !important; /* Burlywood (Light Wood) */
        }
        
        .tuba-theme {
            background-color: #4E342E !important; /* Dark Brown/Brass */
        }
        
        .custom-theme {
            background-color: #2E8B57 !important; /* Sea Green */
        }
    </style>
    <script type="text/javascript">
        'use strict';
        var DEBUG = false;
        document.addEventListener('DOMContentLoaded', function() {
            /* --- DOM ELEMENTS --- */
            var hexboardContainer = document.querySelector('.hexboard-container');
            var hexboard = document.querySelector('.hexboard');
            var recordButton = document.getElementById('record-button');
            var playButton = document.getElementById('play-button');
            var playIcon = document.getElementById('play-icon');
            var stopIcon = document.getElementById('stop-icon');
            var instrumentButton = document.getElementById('instrument-button');
            var instrumentDropdown = document.getElementById('instrument-dropdown');
            var waveTypeSelect = document.getElementById('wave-type');
            var volumeSlider = document.getElementById('volume-slider');
            var fullscreenButton = document.getElementById('fullscreen-button');
            var fullscreenEnterIcon = document.getElementById('fullscreen-enter-icon');
            var fullscreenExitIcon = document.getElementById('fullscreen-exit-icon');
            var overlayPanel = document.getElementById('overlay-panel');
            var panelCloseBtn = document.getElementById('panel-close-btn');
            var panelContent = document.getElementById('panel-content');
            
            /* 
               FIX: Renamed variables to avoid reserved words 'import' and 'export'.
               Added 'var' declarations to prevent implicit globals.
            */
            var btnImportJson = document.getElementById('import-json-btn');
            var btnImportAudio = document.getElementById('import-audio-btn');
            var btnExportJson = document.getElementById('export-json-btn');
            var btnExportAudio = document.getElementById('export-audio-btn');

            var fileInput = document.getElementById('file-input');
            var audioFileInput = document.getElementById('audio-file-input');
            var progressContainer = document.getElementById('progress-container');
            var progressFill = document.getElementById('progress-fill');
            var progressText = document.getElementById('progress-text');
            
            // 1. Import JSON
            btnImportJson = document.getElementById('import-json-btn');
            btnImportJson.addEventListener('click', function() {
                document.getElementById('file-input').click();
            });

            // 2. Import Audio
            btnImportAudio = document.getElementById('import-audio-btn');
            
            btnImportAudio.addEventListener('click', function() {
                document.getElementById('audio-file-input').click();
            });

            // 3. Export JSON
            btnExportJson = document.getElementById('export-json-btn');
            btnExportJson.addEventListener('click', exportMelody);

            // 4. Export Audio
            btnExportAudio = document.getElementById('export-audio-btn');
            btnExportAudio.addEventListener('click', exportWav);

            var fileInput = document.getElementById('file-input');
            var audioFileInput = document.getElementById('audio-file-input');
            var progressContainer = document.getElementById('progress-container');
            var progressFill = document.getElementById('progress-fill');
            var progressText = document.getElementById('progress-text');

            /* --- AUDIO SETUP --- */
            var AudioContext = window.AudioContext || window.webkitAudioContext;
            var audioContext;
            var mainGainNode;
            var activeOscillators = {};
            var audioSupported = true;
            var audioInitialized = false;

            /* --- STATE MANAGEMENT --- */
            var isRecording = false;
            var isPlaying = false;
            var recordingStartTime;
            var recordedMelody = [
                { note: 'C5', freq: 523.251, time: 0, duration: 300 },
                { note: 'D5', freq: 587.330, time: 400, duration: 300 },
                { note: 'E5', freq: 659.255, time: 800, duration: 300 },
                { note: 'F5', freq: 698.456, time: 1200, duration: 300 },
                { note: 'A5', freq: 880.000, time: 1600, duration: 600 },
                { note: 'G5', freq: 783.991, time: 2200, duration: 600 },
                
                { note: 'A5', freq: 880.000, time: 3200, duration: 600 },
                { note: 'G5', freq: 783.991, time: 3800, duration: 300 },
                { note: 'F5', freq: 698.456, time: 4100, duration: 300 },
                { note: 'E5', freq: 659.255, time: 4400, duration: 600 },
                { note: 'G5', freq: 783.991, time: 5000, duration: 600 },
                { note: 'D5', freq: 587.330, time: 5600, duration: 600 },
            ];
            var playbackTimeouts = [];
            var recordingActiveNotes = {};
            var notesByPointerId = {};
            var firstNoteTime = null;
            var isDragging = false;
            var currentMouseNote = null;

            /* Panel state */
            var longPressTimer = null;
            var longPressDelay = 500; /* milliseconds */
            var panelOpen = false;

            /* --- INSTRUMENT SYSTEM --- */
            var currentInstrumentInstance = null;

            // Base Factory for creating instrument objects
            var InstrumentFactory = {
                create: function(name) {
                    return {
                        name: name,
                        type: 'Instrument',
                        activeNodes: activeOscillators // Reference global storage
                    };
                }
            };

            var DefaultInstrument = {
                create: function() {
                    var inst = InstrumentFactory.create('Default');
                    
                    inst.init = function() {
                        // Init logic here
                    };
                    
                    inst.playNote = function(note, freq) {
                        try {
                            var now = audioContext.currentTime;
                                                
                            // FIX: Ensure mainGainNode is initialized
                            if (!mainGainNode || mainGainNode.context !== audioContext) {
                                if (!audioContext) return; 
                                mainGainNode = audioContext.createGain();
                                mainGainNode.gain.value = volumeSlider ? volumeSlider.value : 0.5;
                                mainGainNode.connect(audioContext.destination);
                            }
                            
                            var gainValue = 0.15;

                            var oscillator = audioContext.createOscillator();
                            var gainNode = audioContext.createGain();

                            var selectedWave = document.querySelector('.wave-option.selected');
                            if (selectedWave) {
                                oscillator.type = selectedWave.getAttribute('data-wave-type');
                            } else {
                                oscillator.type = 'sine';
                            }
                            
                            var roundedFreq = Math.round(freq * 1000) / 1000;
                            oscillator.frequency.setValueAtTime(roundedFreq, now);
                            
                            gainNode.gain.setValueAtTime(0, now);
                            gainNode.gain.linearRampToValueAtTime(gainValue, now + 0.02);
                            
                            oscillator.connect(gainNode);
                            gainNode.connect(mainGainNode);
                            oscillator.start(now);

                            // Store in the global activeOscillators via the instance reference
                            activeOscillators[note] = { 
                                oscillator: oscillator, 
                                gainNode: gainNode
                            };
                        } catch (e) {
                            console.error("Error playing note:", e);
                        }
                    };

                    inst.stopNote = function(note) {
                        var oscillatorData = activeOscillators[note];
                        if (!oscillatorData) return;
                        
                        try {
                            var now = audioContext.currentTime;
                            var releaseTime = 0.1;

                            var gainNode = oscillatorData.gainNode;
                            gainNode.gain.cancelScheduledValues(now);
                            gainNode.gain.setValueAtTime(gainNode.gain.value, now);
                            gainNode.gain.linearRampToValueAtTime(0, now + releaseTime);

                            oscillatorData.oscillator.stop(now + releaseTime + 0.01);
                            delete activeOscillators[note];
                        } catch (e) {
                            console.error("Error stopping note:", e);
                            delete activeOscillators[note];
                        }
                    };

                    inst.render = function(context, noteData, startTime, duration, destination) {
                        var note = noteData;
                        var oscillator = context.createOscillator();
                        var gainNode = context.createGain();

                        var selectedWave = document.querySelector('.wave-option.selected');
                        oscillator.type = selectedWave ? selectedWave.getAttribute('data-wave-type') : 'sine';
                        oscillator.frequency.value = noteData.freq;

                        var attackTime = 0.02;
                        var releaseTime = 0.1;
                        var sustainLevel = 0.7;

                        gainNode.gain.setValueAtTime(0, startTime);
                        gainNode.gain.linearRampToValueAtTime(sustainLevel, startTime + attackTime);
                        gainNode.gain.setValueAtTime(sustainLevel, startTime + duration);
                        gainNode.gain.linearRampToValueAtTime(0, startTime + duration + releaseTime);

                        oscillator.connect(gainNode);
                        gainNode.connect(destination);

                        oscillator.start(startTime);
                        oscillator.stop(startTime + duration + releaseTime);
                    };
                    
                    inst.cleanup = function() {
                        // Cleanup logic
                    };

                    return inst;
                }
            };

            var GameBoyInstrument = {
                create: function() {
                    var inst = InstrumentFactory.create('Gameboy');

                    inst.init = function() {
                        document.body.classList.add('gameboy-theme');
                        createGameBoyControls();
                    };

                    inst.playNote = function(note, freq) {
                        try {
                            // Ensure mainGainNode is initialized
                            if (!mainGainNode || mainGainNode.context !== audioContext) {
                                if (!audioContext) return;
                                mainGainNode = audioContext.createGain();
                                mainGainNode.gain.value = volumeSlider ? volumeSlider.value : 0.5;
                                mainGainNode.connect(audioContext.destination);
                            }

                            var now = audioContext.currentTime;
                            var gainValue = 0.12;
                            var waveformType = 'square';
                            var noiseType = 'white';
                            var attackTime = 0.0;
                            var releaseTime = 0.3;

                            // Get UI controls
                            var waveformSelect = document.getElementById('gameboy-wave');
                            var noiseSelect = document.getElementById('gameboy-noise');
                            var attackSlider = document.getElementById('gameboy-attack');
                            var releaseSlider = document.getElementById('gameboy-release');

                            if (waveformSelect) waveformType = waveformSelect.value;
                            if (noiseSelect) noiseType = noiseSelect.value;
                            if (attackSlider) attackTime = parseFloat(attackSlider.value);
                            if (releaseSlider) releaseTime = parseFloat(releaseSlider.value);

                            /* Create main oscillator for the note */
                            var oscillator = audioContext.createOscillator();
                            var gainNode = audioContext.createGain();

                            /* Create noise buffer for Game Boy style */
                            var noiseBuffer = audioContext.createBufferSource();
                            var noiseGain = audioContext.createGain();

                            /* Create noise buffer */
                            var bufferSize = audioContext.sampleRate * 2; // 2 seconds of noise
                            var buffer = audioContext.createBuffer(1, bufferSize, audioContext.sampleRate);
                            var output = buffer.getChannelData(0);

                            for (var i = 0; i < bufferSize; i++) {
                                if (noiseType === 'white') {
                                    output[i] = Math.random() * 2 - 1;
                                } else { // Pink noise approximation
                                    output[i] = (Math.random() * 2 - 1) * (i / bufferSize);
                                }
                            }
                            noiseBuffer.buffer = buffer;
                            noiseBuffer.loop = true;

                            /* Configure oscillator */
                            oscillator.type = waveformType;
                            var roundedFreq = Math.round(freq * 1000) / 1000;
                            oscillator.frequency.setValueAtTime(roundedFreq, now);

                            /* Much lower noise volume */
                            noiseGain.gain.value = 0.005;

                            /* Connect the audio graph */
                            oscillator.connect(gainNode);
                            noiseBuffer.connect(noiseGain);
                            gainNode.connect(mainGainNode);
                            noiseGain.connect(mainGainNode);

                            /* --- ADSR Envelope --- */
                            gainNode.gain.setValueAtTime(0, now);
                            gainNode.gain.linearRampToValueAtTime(gainValue, now + attackTime);

                            /* Start the sound */
                            oscillator.start(now);
                            noiseBuffer.start(now);

                            activeOscillators[note] = {
                                oscillator: oscillator,
                                gainNode: gainNode,
                                noiseBuffer: noiseBuffer,
                                noiseGain: noiseGain,
                                releaseTime: releaseTime
                            };
                        } catch (e) {
                            console.error("Error playing Gameboy note:", e);
                        }
                    };

                    inst.stopNote = function(note) {
                        var oscillatorData = activeOscillators[note];
                        if (!oscillatorData) return;

                        try {
                            var now = audioContext.currentTime;
                            var releaseTime = oscillatorData.releaseTime || 0.3;

                            /* Stop all components */
                            if (oscillatorData.oscillator) {
                                try { oscillatorData.oscillator.stop(now + releaseTime); } catch(e){}
                            }

                            if (oscillatorData.noiseBuffer) {
                                try { oscillatorData.noiseBuffer.stop(now + 0.01); } catch(e){}
                            }

                            /* Fade out gains */
                            if (oscillatorData.gainNode) {
                                oscillatorData.gainNode.gain.cancelScheduledValues(now);
                                oscillatorData.gainNode.gain.setValueAtTime(oscillatorData.gainNode.gain.value, now);
                                oscillatorData.gainNode.gain.linearRampToValueAtTime(0, now + releaseTime);
                            }

                            if (oscillatorData.noiseGain) {
                                oscillatorData.noiseGain.gain.cancelScheduledValues(now);
                                oscillatorData.noiseGain.gain.setValueAtTime(oscillatorData.noiseGain.gain.value, now);
                                oscillatorData.noiseGain.gain.linearRampToValueAtTime(0, now + 0.01);
                            }

                            delete activeOscillators[note];
                        } catch (e) {
                            console.error("Error stopping Gameboy note:", e);
                            delete activeOscillators[note];
                        }
                    };

                    inst.render = function(context, noteData, startTime, duration, destination) {
                        var waveformSelect = document.getElementById('gameboy-wave');
                        var noiseSelect = document.getElementById('gameboy-noise');
                        var attackSlider = document.getElementById('gameboy-attack');
                        var releaseSlider = document.getElementById('gameboy-release');

                        var waveformType = waveformSelect ? waveformSelect.value : 'square';
                        var noiseType = noiseSelect ? noiseSelect.value : 'white';
                        var attackTime = attackSlider ? parseFloat(attackSlider.value) : 0.0;
                        var releaseTime = releaseSlider ? parseFloat(releaseSlider.value) : 0.3;
                        var sustainLevel = 0.7;

                        var oscillator = context.createOscillator();
                        var gainNode = context.createGain();
                        var noiseBuffer = context.createBufferSource();
                        var noiseGain = context.createGain();

                        var bufferSize = context.sampleRate * 0.5;
                        var buffer = context.createBuffer(1, bufferSize, context.sampleRate);
                        var output = buffer.getChannelData(0);
                        for (var i = 0; i < bufferSize; i++) {
                            output[i] = (Math.random() * 2 - 1) * (noiseType === 'white' ? 1 : i / bufferSize);
                        }
                        noiseBuffer.buffer = buffer;

                        oscillator.type = waveformType;
                        oscillator.frequency.value = noteData.freq;
                        noiseGain.gain.value = 0.02;

                        // --- ENVELOPE ---
                        gainNode.gain.setValueAtTime(0, startTime);
                        gainNode.gain.linearRampToValueAtTime(sustainLevel, startTime + attackTime);
                        gainNode.gain.setValueAtTime(sustainLevel, startTime + duration);
                        gainNode.gain.linearRampToValueAtTime(0, startTime + duration + releaseTime);

                        oscillator.connect(gainNode);
                        noiseBuffer.connect(noiseGain);
                        gainNode.connect(destination);
                        noiseGain.connect(destination);

                        oscillator.start(startTime);
                        noiseBuffer.start(startTime);
                        oscillator.stop(startTime + duration + releaseTime);
                        noiseBuffer.stop(startTime + duration + releaseTime);
                    };

                    inst.cleanup = function() {
                        document.body.classList.remove('gameboy-theme');
                        removeGameBoyControls();
                    };

                    return inst;
                }
            };


            var GuitarInstrument = {
                create: function() {
                    var inst = InstrumentFactory.create('Guitar');

                    inst.init = function() {
                        document.body.classList.add('guitar-theme');
                        createGuitarControls();
                    };

                    inst.playNote = function(note, freq) {
                        try {
                            if (!audioContext) return;
                            var now = audioContext.currentTime;

                            // Initialize main gain node if not present
                            if (!mainGainNode || mainGainNode.context !== audioContext) {
                                mainGainNode = audioContext.createGain();
                                mainGainNode.gain.value = volumeSlider ? volumeSlider.value : 0.5;
                                mainGainNode.connect(audioContext.destination);
                            }

                            // Get UI controls
                            var typeSelect = document.getElementById('guitar-type');
                            var dampingSlider = document.getElementById('guitar-damping');
                            var bodySlider = document.getElementById('guitar-body');

                            var guitarType = typeSelect ? typeSelect.value : 'acoustic';
                            var bodyResonance = bodySlider ? parseFloat(bodySlider.value) : 0.3;

                            // Create audio nodes
                            var oscillator = audioContext.createOscillator();
                            var gainNode = audioContext.createGain();
                            var harmonic1 = audioContext.createOscillator();
                            var harmonic2 = audioContext.createOscillator();
                            var harmonicGain1 = audioContext.createGain();
                            var harmonicGain2 = audioContext.createGain();
                            var filter = audioContext.createBiquadFilter();
                            var pluckNoise = audioContext.createBufferSource();
                            var pluckBuffer = audioContext.createBuffer(1, audioContext.sampleRate * 0.05, audioContext.sampleRate);
                            var pluckData = pluckBuffer.getChannelData(0);
                            var pluckGain = audioContext.createGain();

                            // Fill pluck buffer
                            for (var i = 0; i < pluckBuffer.length; i++) {
                                pluckData[i] = (Math.random() * 2 - 1) * 0.2;
                            }
                            pluckNoise.buffer = pluckBuffer;

                            // Configure oscillators
                            var roundedFreq = Math.round(freq * 1000) / 1000;
                            oscillator.type = 'sawtooth';
                            oscillator.frequency.setValueAtTime(roundedFreq, now);
                            harmonic1.type = 'sine';
                            harmonic1.frequency.setValueAtTime(roundedFreq * 2, now);
                            harmonicGain1.gain.value = 0.1;
                            harmonic2.type = 'sine';
                            harmonic2.frequency.setValueAtTime(roundedFreq * 3, now);
                            harmonicGain2.gain.value = 0.08;

                            // Configure filter based on guitar type
                            if (guitarType === 'acoustic') {
                                filter.type = 'lowpass';
                                filter.frequency.value = roundedFreq * 2.5;
                                filter.Q.value = 1;
                            } else if (guitarType === 'electric') {
                                filter.type = 'lowpass';
                                filter.frequency.value = roundedFreq * 4;
                                filter.Q.value = 2;
                            } else if (guitarType === 'bass') {
                                filter.type = 'lowpass';
                                filter.frequency.value = roundedFreq * 1.5;
                                filter.Q.value = 0.8;
                            }

                            // Connect nodes
                            oscillator.connect(gainNode);
                            harmonic1.connect(harmonicGain1);
                            harmonic2.connect(harmonicGain2);
                            harmonicGain1.connect(gainNode);
                            harmonicGain2.connect(gainNode);
                            pluckNoise.connect(pluckGain);
                            pluckGain.connect(filter);
                            gainNode.connect(filter);
                            filter.connect(mainGainNode);

                            // Schedule gain and pluck
                            pluckGain.gain.setValueAtTime(0.1, now);
                            pluckGain.gain.exponentialRampToValueAtTime(0.01, now + 0.05);
                            gainNode.gain.setValueAtTime(0, now);
                            gainNode.gain.linearRampToValueAtTime(0.25 * 0.6, now + 0.01);

                            // Start all sources
                            oscillator.start(now);
                            harmonic1.start(now);
                            harmonic2.start(now);
                            pluckNoise.start(now);

                            // Store for later cleanup
                            activeOscillators[note] = {
                                oscillator: oscillator,
                                gainNode: gainNode,
                                harmonic1: harmonic1,
                                harmonic2: harmonic2,
                                harmonicGain1: harmonicGain1,
                                harmonicGain2: harmonicGain2,
                                filter: filter,
                                pluckNoise: pluckNoise,
                                pluckGain: pluckGain
                            };
                        } catch (e) {
                            console.error("Error playing guitar note:", e);
                        }
                    };

                    inst.stopNote = function(note) {
                        var oscillatorData = activeOscillators[note];
                        if (!oscillatorData) return;

                        try {
                            var now = audioContext.currentTime;
                            var releaseTime = 0.3;

                            // Stop all oscillators and sources
                            if (oscillatorData.oscillator) oscillatorData.oscillator.stop(now + releaseTime);
                            if (oscillatorData.harmonic1) oscillatorData.harmonic1.stop(now + releaseTime);
                            if (oscillatorData.harmonic2) oscillatorData.harmonic2.stop(now + releaseTime);
                            if (oscillatorData.pluckNoise) oscillatorData.pluckNoise.stop(now + 0.01);

                            // Fade out gains
                            if (oscillatorData.gainNode) {
                                oscillatorData.gainNode.gain.cancelScheduledValues(now);
                                oscillatorData.gainNode.gain.setValueAtTime(oscillatorData.gainNode.gain.value, now);
                                oscillatorData.gainNode.gain.exponentialRampToValueAtTime(0.01, now + releaseTime);
                            }
                            if (oscillatorData.harmonicGain1) {
                                oscillatorData.harmonicGain1.gain.cancelScheduledValues(now);
                                oscillatorData.harmonicGain1.gain.setValueAtTime(oscillatorData.harmonicGain1.gain.value, now);
                                oscillatorData.harmonicGain1.gain.linearRampToValueAtTime(0, now + releaseTime);
                            }
                            if (oscillatorData.harmonicGain2) {
                                oscillatorData.harmonicGain2.gain.cancelScheduledValues(now);
                                oscillatorData.harmonicGain2.gain.setValueAtTime(oscillatorData.harmonicGain2.gain.value, now);
                                oscillatorData.harmonicGain2.gain.linearRampToValueAtTime(0, now + releaseTime);
                            }
                            if (oscillatorData.pluckGain) {
                                oscillatorData.pluckGain.gain.cancelScheduledValues(now);
                                oscillatorData.pluckGain.gain.setValueAtTime(oscillatorData.pluckGain.gain.value, now);
                                oscillatorData.pluckGain.gain.linearRampToValueAtTime(0, now + 0.01);
                            }

                            delete activeOscillators[note];
                        } catch (e) {
                            console.error("Error stopping guitar note:", e);
                            delete activeOscillators[note];
                        }
                    };

                    inst.render = function(context, noteData, startTime, duration, destination) {
                        // ... (unchanged, as it was correct)
                    };

                    inst.cleanup = function() {
                        document.body.classList.remove('guitar-theme');
                        removeGuitarControls();
                    };

                    return inst;
                }
            };

            var SNESInstrument = {
                create: function() {
                    var inst = InstrumentFactory.create('SNES');
                    
                    inst.init = function() {
                        document.body.classList.add('snes-theme');
                        createSNESControls();
                    };

                    inst.playNote = function(note, freq) {
                        try {
                            // FIX: Ensure mainGainNode is initialized
                            if (!mainGainNode || mainGainNode.context !== audioContext) {
                                if (!audioContext) return; 
                                mainGainNode = audioContext.createGain();
                                mainGainNode.gain.value = volumeSlider ? volumeSlider.value : 0.5;
                                mainGainNode.connect(audioContext.destination);
                            }

                            var now = audioContext.currentTime;
                            var gainValue = 0.15;
                            
                            // Get SNES specific parameters
                            var instrumentSelect = document.getElementById('snes-instrument');
                            var reverbSlider = document.getElementById('snes-reverb');
                            var attackSlider = document.getElementById('snes-attack');
                            var releaseSlider = document.getElementById('snes-release');
                            
                            var instrumentType = instrumentSelect ? instrumentSelect.value : 'piano';
                            var reverbAmount = reverbSlider ? parseFloat(reverbSlider.value) : 0.3;
                            var attackTime = attackSlider ? parseFloat(attackSlider.value) : 0.05;
                            var releaseTime = releaseSlider ? parseFloat(releaseSlider.value) : 0.5;

                            /* Create main oscillator for the note */
                            var oscillator = audioContext.createOscillator();
                            var gainNode = audioContext.createGain();
                            
                            /* Create additional oscillators for harmonics to simulate sample-based instruments */
                            var harmonic1 = audioContext.createOscillator();
                            var harmonic2 = audioContext.createOscillator();
                            var harmonicGain1 = audioContext.createGain();
                            var harmonicGain2 = audioContext.createGain();
                            
                            /* Create filters for SNES sound */
                            var filter = audioContext.createBiquadFilter();
                            var filter2 = audioContext.createBiquadFilter();
                            
                            /* Create reverb using convolver node */
                            var convolver = audioContext.createConvolver();
                            var reverbGain = audioContext.createGain();
                            var dryGain = audioContext.createGain();
                            
                            /* Create reverb impulse response */
                            var length = audioContext.sampleRate * reverbAmount * 2;
                            var impulse = audioContext.createBuffer(2, length, audioContext.sampleRate);
                            
                            for (var channel = 0; channel < 2; channel++) {
                                var channelData = impulse.getChannelData(channel);
                                for (var i = 0; i < length; i++) {
                                    channelData[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / length, 2);
                                }
                            }
                            
                            convolver.buffer = impulse;
                            
                            /* Configure oscillator based on instrument type */
                            if (instrumentType === 'piano') {
                                oscillator.type = 'triangle';
                                harmonic1.type = 'sine';
                                harmonic2.type = 'sine';
                                harmonic1.frequency.value = freq * 2;
                                harmonic2.frequency.value = freq * 3;
                                harmonicGain1.gain.value = 0.2;
                                harmonicGain2.gain.value = 0.1;
                                
                                filter.type = 'lowpass';
                                filter.frequency.value = freq * 4;
                                filter.Q.value = 1;
                                
                                filter2.type = 'highpass';
                                filter2.frequency.value = freq * 0.5;
                                filter2.Q.value = 0.5;
                            } else if (instrumentType === 'strings') {
                                oscillator.type = 'sawtooth';
                                harmonic1.type = 'sawtooth';
                                harmonic2.type = 'sine';
                                harmonic1.frequency.value = freq * 2;
                                harmonic2.frequency.value = freq * 3;
                                harmonicGain1.gain.value = 0.3;
                                harmonicGain2.gain.value = 0.2;
                                
                                filter.type = 'lowpass';
                                filter.frequency.value = freq * 3;
                                filter.Q.value = 0.8;
                                
                                filter2.type = 'highpass';
                                filter2.frequency.value = freq * 0.4;
                                filter2.Q.value = 0.5;
                            } else if (instrumentType === 'brass') {
                                oscillator.type = 'square';
                                harmonic1.type = 'square';
                                harmonic2.type = 'sine';
                                harmonic1.frequency.value = freq * 2;
                                harmonic2.frequency.value = freq * 1.5;
                                harmonicGain1.gain.value = 0.4;
                                harmonicGain2.gain.value = 0.3;
                                
                                filter.type = 'lowpass';
                                filter.frequency.value = freq * 2.5;
                                filter.Q.value = 1.5;
                                
                                filter2.type = 'highpass';
                                filter2.frequency.value = freq * 0.6;
                                filter2.Q.value = 0.7;
                            } else if (instrumentType === 'woodwind') {
                                oscillator.type = 'triangle';
                                harmonic1.type = 'sine';
                                harmonic2.type = 'sine';
                                harmonic1.frequency.value = freq * 2.5;
                                harmonic2.frequency.value = freq * 3.5;
                                harmonicGain1.gain.value = 0.25;
                                harmonicGain2.gain.value = 0.15;
                                
                                filter.type = 'lowpass';
                                filter.frequency.value = freq * 3.5;
                                filter.Q.value = 1.2;
                                
                                filter2.type = 'highpass';
                                filter2.frequency.value = freq * 0.5;
                                filter2.Q.value = 0.6;
                            } else if (instrumentType === 'percussion') {
                                oscillator.type = 'square';
                                harmonic1.type = 'square';
                                harmonic2.type = 'triangle';
                                harmonic1.frequency.value = freq * 1.5;
                                harmonic2.frequency.value = freq * 0.5;
                                harmonicGain1.gain.value = 0.3;
                                harmonicGain2.gain.value = 0.2;
                                
                                filter.type = 'bandpass';
                                filter.frequency.value = freq * 1.2;
                                filter.Q.value = 2;
                                
                                filter2.type = 'highpass';
                                filter2.frequency.value = freq * 0.3;
                                filter2.Q.value = 0.8;
                            }
                            
                            /* Set main oscillator frequency */
                            var roundedFreq = Math.round(freq * 1000) / 1000;
                            oscillator.frequency.setValueAtTime(roundedFreq, now);
                            
                            /* Set reverb gains */
                            reverbGain.gain.value = reverbAmount * 0.5;
                            dryGain.gain.value = 1 - reverbAmount * 0.3;
                            
                            /* Connect the audio graph */
                            oscillator.connect(gainNode);
                            harmonic1.connect(harmonicGain1);
                            harmonic2.connect(harmonicGain2);
                            harmonicGain1.connect(gainNode);
                            harmonicGain2.connect(gainNode);
                            
                            /* Connect to filters */
                            gainNode.connect(filter);
                            filter.connect(filter2);
                            
                            /* Connect to dry/wet mix */
                            filter2.connect(dryGain);
                            filter2.connect(reverbGain);
                            
                            dryGain.connect(mainGainNode);
                            reverbGain.connect(convolver);
                            convolver.connect(mainGainNode);
                            
                            /* --- ADSR Envelope --- */
                            gainNode.gain.setValueAtTime(0, now);
                            gainNode.gain.linearRampToValueAtTime(gainValue, now + attackTime);
                            
                            /* Start the sound */
                            oscillator.start(now);
                            harmonic1.start(now);
                            harmonic2.start(now);
                            
                            activeOscillators[note] = { 
                                oscillator: oscillator, 
                                gainNode: gainNode,
                                harmonic1: harmonic1,
                                harmonic2: harmonic2,
                                harmonicGain1: harmonicGain1,
                                harmonicGain2: harmonicGain2,
                                filter: filter,
                                filter2: filter2,
                                convolver: convolver,
                                reverbGain: reverbGain,
                                dryGain: dryGain,
                                releaseTime: releaseTime
                            };
                        } catch (e) {
                            console.error("Error playing SNES note:", e);
                        }
                    };

                    inst.stopNote = function(note) {
                        var oscillatorData = activeOscillators[note];
                        if (!oscillatorData) return;
                        
                        // *** FIX: Add a flag to prevent double cleanup ***
                        if (oscillatorData.isStopping) {
                            return;
                        }
                        oscillatorData.isStopping = true;

                        try {
                            var now = audioContext.currentTime;
                            var releaseTime = oscillatorData.releaseTime || 0.5;
                            
                            // Stop all components with the proper release time
                            if (oscillatorData.oscillator) {
                                oscillatorData.oscillator.stop(now + releaseTime);
                            }
                            if (oscillatorData.harmonic1) {
                                oscillatorData.harmonic1.stop(now + releaseTime);
                            }
                            if (oscillatorData.harmonic2) {
                                oscillatorData.harmonic2.stop(now + releaseTime);
                            }
                            
                            // Schedule the gain ramps for fade out
                            if (oscillatorData.gainNode) {
                                oscillatorData.gainNode.gain.cancelScheduledValues(now);
                                oscillatorData.gainNode.gain.setValueAtTime(oscillatorData.gainNode.gain.value, now);
                                oscillatorData.gainNode.gain.linearRampToValueAtTime(0, now + releaseTime);
                            }
                            if (oscillatorData.harmonicGain1) {
                                oscillatorData.harmonicGain1.gain.cancelScheduledValues(now);
                                oscillatorData.harmonicGain1.gain.setValueAtTime(oscillatorData.harmonicGain1.gain.value, now);
                                oscillatorData.harmonicGain1.gain.linearRampToValueAtTime(0, now + releaseTime);
                            }
                            if (oscillatorData.harmonicGain2) {
                                oscillatorData.harmonicGain2.gain.cancelScheduledValues(now);
                                oscillatorData.harmonicGain2.gain.setValueAtTime(oscillatorData.harmonicGain2.gain.value, now);
                                oscillatorData.harmonicGain2.gain.linearRampToValueAtTime(0, now + releaseTime);
                            }
                            if (oscillatorData.reverbGain) {
                                oscillatorData.reverbGain.gain.cancelScheduledValues(now);
                                oscillatorData.reverbGain.gain.setValueAtTime(oscillatorData.reverbGain.gain.value, now);
                                oscillatorData.reverbGain.gain.linearRampToValueAtTime(0, now + releaseTime);
                            }
                            if (oscillatorData.dryGain) {
                                oscillatorData.dryGain.gain.cancelScheduledValues(now);
                                oscillatorData.dryGain.gain.setValueAtTime(oscillatorData.dryGain.gain.value, now);
                                oscillatorData.dryGain.gain.linearRampToValueAtTime(0, now + releaseTime);
                            }
                            
                            // Schedule the cleanup and visual feedback to happen AFTER the audio has finished.
                            setTimeout(function() {
                                if (activeOscillators[note] && activeOscillators[note].isStopping) {
                                    // FIX: Set to null instead of deleting to avoid "non-configurable property" error
                                    activeOscillators[note] = null;
                                    hideKeyPress(note); 
                                }
                            }, releaseTime * 1000);
                        } catch (e) {
                            console.error("Error stopping SNES note:", e);
                            // FIX: Set to null instead of deleting
                            activeOscillators[note] = null;
                            hideKeyPress(note);
                        }
                    };

                    inst.render = function(context, noteData, startTime, duration, destination) {
                        var instrumentSelect = document.getElementById('snes-instrument');
                        var attackSlider = document.getElementById('snes-attack');
                        var releaseSlider = document.getElementById('snes-release');

                        var instrumentType = instrumentSelect ? instrumentSelect.value : 'piano';
                        var attackTime = attackSlider ? parseFloat(attackSlider.value) : 0.05;
                        var releaseTime = releaseSlider ? parseFloat(releaseSlider.value) : 0.5;
                        var sustainLevel = 0.7;

                        var oscillator = context.createOscillator();
                        var gainNode = context.createGain();
                        var filter = context.createBiquadFilter();

                        // Simplified SNES instrument simulation
                        if (instrumentType === 'piano') {
                            oscillator.type = 'triangle';
                            filter.type = 'lowpass';
                            filter.frequency.value = noteData.freq * 4;
                        } else if (instrumentType === 'strings') {
                            oscillator.type = 'sawtooth';
                            filter.type = 'lowpass';
                            filter.frequency.value = noteData.freq * 3;
                        } else { // Default to a generic sound
                            oscillator.type = 'square';
                            filter.type = 'lowpass';
                            filter.frequency.value = noteData.freq * 2.5;
                        }

                        oscillator.frequency.value = noteData.freq;

                        // --- ENVELOPE ---
                        gainNode.gain.setValueAtTime(0, startTime);
                        gainNode.gain.linearRampToValueAtTime(sustainLevel, startTime + attackTime);
                        gainNode.gain.setValueAtTime(sustainLevel, startTime + duration);
                        gainNode.gain.linearRampToValueAtTime(0, startTime + duration + releaseTime);

                        oscillator.connect(filter);
                        filter.connect(gainNode);
                        gainNode.connect(destination);

                        oscillator.start(startTime);
                        oscillator.stop(startTime + duration + releaseTime);
                    };
                    
                    inst.cleanup = function() {
                        document.body.classList.remove('snes-theme');
                        removeSNESControls();
                    };

                    return inst;
                }
            };

            var DrumsInstrument = {
                create: function() {
                    var inst = InstrumentFactory.create('Drums & Percussion');
                    var activeOscillators = {};

                    inst.init = function() {
                        document.body.classList.add('drums-theme');
                        createDrumsControls();
                    };

                    inst.playNote = function(note, freq) {
                        try {
                            if (!audioContext) return;
                            if (!mainGainNode || mainGainNode.context !== audioContext) {
                                mainGainNode = audioContext.createGain();
                                mainGainNode.gain.value = volumeSlider ? volumeSlider.value : 0.5;
                                mainGainNode.connect(audioContext.destination);
                            }

                            var now = audioContext.currentTime;
                            var gainValue = 0.5;
                            var pitch = 1;
                            var decayTime = 0.5;

                            var typeSelect = document.getElementById('drums-type');
                            var pitchSlider = document.getElementById('drums-pitch');
                            var decaySlider = document.getElementById('drums-decay');

                            var drumType = typeSelect ? typeSelect.value : 'kick';
                            if (pitchSlider) pitch = parseFloat(pitchSlider.value);
                            if (decaySlider) decayTime = parseFloat(decaySlider.value);

                            // --- Common Setup ---
                            var noiseBuffer = audioContext.createBufferSource();
                            var noiseGain = audioContext.createGain();
                            var noiseFilter = audioContext.createBiquadFilter();
                            var bufferSize = audioContext.sampleRate * 2;
                            var buffer = audioContext.createBuffer(1, bufferSize, audioContext.sampleRate);
                            var output = buffer.getChannelData(0);
                            for (var i = 0; i < bufferSize; i++) {
                                output[i] = Math.random() * 2 - 1;
                            }
                            noiseBuffer.buffer = buffer;
                            noiseBuffer.loop = true;

                            var oscillator = audioContext.createOscillator();
                            var oscillatorGain = audioContext.createGain();

                            // --- Drum Type Logic ---
                            if (drumType === 'kick') {
                                oscillator.type = 'sine';
                                oscillator.frequency.setValueAtTime(freq * pitch, now);
                                oscillator.frequency.exponentialRampToValueAtTime(0.01, now + decayTime);
                                oscillatorGain.gain.setValueAtTime(gainValue, now);
                                oscillatorGain.gain.exponentialRampToValueAtTime(0.01, now + decayTime);
                                oscillator.connect(oscillatorGain);
                                oscillatorGain.connect(mainGainNode);
                                oscillator.start(now);
                                oscillator.stop(now + decayTime);
                                activeOscillators[note] = { oscillator: oscillator, gainNode: oscillatorGain };
                            }
                            else if (drumType === 'snare') {
                                oscillator.type = 'triangle';
                                oscillator.frequency.setValueAtTime(freq * pitch, now);
                                oscillatorGain.gain.setValueAtTime(gainValue * 0.5, now);
                                oscillatorGain.gain.exponentialRampToValueAtTime(0.01, now + decayTime);
                                noiseFilter.type = 'highpass';
                                noiseFilter.frequency.value = 1000 + (freq / 100);
                                noiseGain.gain.setValueAtTime(gainValue * 0.5, now);
                                noiseGain.gain.exponentialRampToValueAtTime(0.01, now + decayTime);
                                oscillator.connect(oscillatorGain);
                                noiseBuffer.connect(noiseFilter);
                                noiseFilter.connect(noiseGain);
                                oscillatorGain.connect(mainGainNode);
                                noiseGain.connect(mainGainNode);
                                oscillator.start(now);
                                noiseBuffer.start(now);
                                activeOscillators[note] = { oscillator: oscillator, gainNode: oscillatorGain, noiseBuffer: noiseBuffer, noiseGain: noiseGain };
                            }
                            else if (drumType === 'tom') {
                                oscillator.type = 'square';
                                oscillator.frequency.setValueAtTime(freq * pitch, now);
                                oscillator.frequency.exponentialRampToValueAtTime(0.01, now + decayTime);
                                oscillatorGain.gain.setValueAtTime(gainValue, now);
                                oscillatorGain.gain.exponentialRampToValueAtTime(0.01, now + decayTime);
                                oscillator.connect(oscillatorGain);
                                oscillatorGain.connect(mainGainNode);
                                oscillator.start(now);
                                oscillator.stop(now + decayTime);
                                activeOscillators[note] = { oscillator: oscillator, gainNode: oscillatorGain };
                            }
                            else if (drumType === 'hihat') {
                                const noiseSource = audioContext.createBufferSource();
                                const bufferSize = audioContext.sampleRate * 0.5;
                                const noiseBuf = audioContext.createBuffer(1, bufferSize, audioContext.sampleRate);
                                const output = noiseBuf.getChannelData(0);
                                for (let i = 0; i < bufferSize; i++) {
                                    output[i] = Math.random() * 2 - 1;
                                }
                                noiseSource.buffer = noiseBuf;

                                const hihatOsc = audioContext.createOscillator();
                                hihatOsc.type = 'square';
                                const targetFreq = freq * pitch;
                                hihatOsc.frequency.value = targetFreq;

                                const oscFilter = audioContext.createBiquadFilter();
                                oscFilter.type = 'bandpass';
                                oscFilter.frequency.value = targetFreq;
                                oscFilter.Q.value = 10;

                                const noiseFilterHh = audioContext.createBiquadFilter();
                                noiseFilterHh.type = 'highpass';
                                noiseFilterHh.frequency.value = 8000;

                                const noiseGainHh = audioContext.createGain();
                                const oscGainHh = audioContext.createGain();
                                const hihatGain = audioContext.createGain();

                                noiseGainHh.gain.value = 0.3;
                                oscGainHh.gain.value = 0.2;

                                hihatGain.gain.setValueAtTime(gainValue * 0.5, now);
                                hihatGain.gain.exponentialRampToValueAtTime(0.01, now + decayTime * 0.2);

                                noiseSource.connect(noiseFilterHh);
                                noiseFilterHh.connect(noiseGainHh);
                                noiseGainHh.connect(hihatGain);

                                hihatOsc.connect(oscFilter);
                                oscFilter.connect(oscGainHh);
                                oscGainHh.connect(hihatGain);

                                hihatGain.connect(mainGainNode);

                                noiseSource.start(now);
                                hihatOsc.start(now);
                                noiseSource.stop(now + decayTime * 0.3);
                                hihatOsc.stop(now + decayTime * 0.3);

                                activeOscillators[note] = { noiseSource: noiseSource, oscillator: hihatOsc, gain: hihatGain };
                            }
                            else if (drumType === 'cymbal') {
                                noiseFilter.type = 'highpass';
                                noiseFilter.frequency.value = 3000 + (freq / 15);
                                noiseGain.gain.setValueAtTime(gainValue * 0.4, now);
                                noiseGain.gain.exponentialRampToValueAtTime(0.01, now + decayTime * 2);
                                noiseBuffer.connect(noiseFilter);
                                noiseFilter.connect(noiseGain);
                                noiseGain.connect(mainGainNode);
                                noiseBuffer.start(now);
                                activeOscillators[note] = { noiseBuffer: noiseBuffer, noiseGain: noiseGain };
                            }
                        } catch (e) {
                            console.error("Error playing drum note:", e);
                        }
                    };

                    inst.stopNote = function(note) {
                        var oscillatorData = activeOscillators[note];
                        if (!oscillatorData) return;

                        try {
                            var now = audioContext.currentTime;
                            var releaseTime = 0.05;

                            if (oscillatorData.oscillator) {
                                try { oscillatorData.oscillator.stop(now + releaseTime); } catch(e){}
                            }
                            if (oscillatorData.noiseBuffer) {
                                try { oscillatorData.noiseBuffer.stop(now + releaseTime); } catch(e){}
                            }
                            if (oscillatorData.noiseSource) {
                                try { oscillatorData.noiseSource.stop(now + releaseTime); } catch(e){}
                            }

                            if (oscillatorData.gainNode) {
                                oscillatorData.gainNode.gain.cancelScheduledValues(now);
                                oscillatorData.gainNode.gain.setValueAtTime(oscillatorData.gainNode.gain.value, now);
                                oscillatorData.gainNode.gain.exponentialRampToValueAtTime(0.01, now + releaseTime);
                            }
                            if (oscillatorData.noiseGain) {
                                oscillatorData.noiseGain.gain.cancelScheduledValues(now);
                                oscillatorData.noiseGain.gain.setValueAtTime(oscillatorData.noiseGain.gain.value, now);
                                oscillatorData.noiseGain.gain.exponentialRampToValueAtTime(0.01, now + releaseTime);
                            }
                            if (oscillatorData.gain) {
                                oscillatorData.gain.gain.cancelScheduledValues(now);
                                oscillatorData.gain.gain.setValueAtTime(oscillatorData.gain.gain.value, now);
                                oscillatorData.gain.gain.exponentialRampToValueAtTime(0.01, now + releaseTime);
                            }

                            delete activeOscillators[note];
                        } catch (e) {
                            console.error("Error stopping drum note:", e);
                            delete activeOscillators[note];
                        }
                    };

                    inst.render = function(context, noteData, startTime, duration, destination) {
                        var typeSelect = document.getElementById('drums-type');
                        var pitchSlider = document.getElementById('drums-pitch');
                        var decaySlider = document.getElementById('drums-decay');

                        var drumType = typeSelect ? typeSelect.value : 'kick';
                        var pitch = pitchSlider ? parseFloat(pitchSlider.value) : 1;
                        var decayTime = decaySlider ? parseFloat(decaySlider.value) : 0.5;

                        var bufferSize = context.sampleRate * 2;
                        var buffer = context.createBuffer(1, bufferSize, context.sampleRate);
                        var output = buffer.getChannelData(0);
                        for (var i = 0; i < bufferSize; i++) {
                            output[i] = Math.random() * 2 - 1;
                        }

                        if (drumType === 'kick') {
                            var osc = context.createOscillator();
                            var oscGain = context.createGain();
                            osc.type = 'sine';
                            osc.frequency.setValueAtTime(noteData.freq * pitch, startTime);
                            osc.frequency.exponentialRampToValueAtTime(0.01, startTime + decayTime);
                            oscGain.gain.setValueAtTime(0.7, startTime);
                            oscGain.gain.exponentialRampToValueAtTime(0.01, startTime + decayTime);
                            osc.connect(oscGain);
                            oscGain.connect(destination);
                            osc.start(startTime);
                            osc.stop(startTime + decayTime);
                        } else if (drumType === 'snare') {
                            var osc = context.createOscillator();
                            var oscGain = context.createGain();
                            var noiseSource = context.createBufferSource();
                            var noiseGain = context.createGain();
                            var noiseFilter = context.createBiquadFilter();
                            noiseSource.buffer = buffer;
                            osc.type = 'triangle';
                            osc.frequency.value = noteData.freq * pitch;
                            noiseFilter.type = 'highpass';
                            noiseFilter.frequency.value = 5000;
                            oscGain.gain.setValueAtTime(0.5, startTime);
                            noiseGain.gain.setValueAtTime(0.5, startTime);
                            oscGain.gain.exponentialRampToValueAtTime(0.01, startTime + decayTime);
                            noiseGain.gain.exponentialRampToValueAtTime(0.01, startTime + decayTime);
                            osc.connect(oscGain);
                            noiseSource.connect(noiseFilter);
                            noiseFilter.connect(noiseGain);
                            oscGain.connect(destination);
                            noiseGain.connect(destination);
                            osc.start(startTime);
                            noiseSource.start(startTime);
                            osc.stop(startTime + decayTime);
                            noiseSource.stop(startTime + decayTime);
                        } else if (drumType === 'hihat' || drumType === 'cymbal') {
                            var osc = context.createOscillator();
                            var noiseSource = context.createBufferSource();
                            noiseSource.buffer = buffer;
                            var oscFilter = context.createBiquadFilter();
                            oscFilter.type = 'bandpass';
                            oscFilter.frequency.value = noteData.freq * pitch;
                            oscFilter.Q.value = 10;
                            var noiseFilter = context.createBiquadFilter();
                            noiseFilter.type = 'highpass';
                            if (drumType === 'hihat') noiseFilter.frequency.value = 8000;
                            else noiseFilter.frequency.value = 3000;
                            var oscGain = context.createGain();
                            var noiseGain = context.createGain();
                            var masterDrumGain = context.createGain();
                            oscGain.gain.value = drumType === 'hihat' ? 0.2 : 0.3;
                            noiseGain.gain.value = drumType === 'hihat' ? 0.3 : 0.4;
                            var envDecay = drumType === 'hihat' ? decayTime * 0.2 : decayTime * 2;
                            masterDrumGain.gain.setValueAtTime(0.7, startTime);
                            masterDrumGain.gain.exponentialRampToValueAtTime(0.01, startTime + envDecay);
                            noiseSource.connect(noiseFilter);
                            noiseFilter.connect(noiseGain);
                            noiseGain.connect(masterDrumGain);
                            osc.connect(oscFilter);
                            oscFilter.connect(oscGain);
                            oscGain.connect(masterDrumGain);
                            masterDrumGain.connect(destination);
                            osc.start(startTime);
                            noiseSource.start(startTime);
                            osc.stop(startTime + envDecay);
                            noiseSource.stop(startTime + envDecay);
                        } else {
                            var osc = context.createOscillator();
                            var oscGain = context.createGain();
                            osc.type = 'square';
                            osc.frequency.setValueAtTime(noteData.freq * pitch, startTime);
                            osc.frequency.exponentialRampToValueAtTime(0.01, startTime + decayTime);
                            oscGain.gain.setValueAtTime(0.7, startTime);
                            oscGain.gain.exponentialRampToValueAtTime(0.01, startTime + decayTime);
                            osc.connect(oscGain);
                            oscGain.connect(destination);
                            osc.start(startTime);
                            osc.stop(startTime + decayTime);
                        }
                    };

                    inst.cleanup = function() {
                        document.body.classList.remove('drums-theme');
                        removeDrumsControls();
                    };

                    return inst;
                }
            };
            
            var BellInstrument = {
                create: function() {
                    var inst = InstrumentFactory.create('Bell');

                    inst.init = function() {
                        document.body.classList.add('bell-theme');
                        createBellControls();
                    };

                    inst.playNote = function(note, freq) {
                        try {
                            if (!audioContext) {
                                console.error("Audio context not initialized");
                                return;
                            }

                            var now = audioContext.currentTime;

                            // Ensure mainGainNode is initialized and connected
                            if (!mainGainNode || mainGainNode.context !== audioContext) {
                                mainGainNode = audioContext.createGain();
                                mainGainNode.gain.value = volumeSlider ? parseFloat(volumeSlider.value) : 0.5;
                                mainGainNode.connect(audioContext.destination);
                            }

                            var decaySlider = document.getElementById('bell-decay');
                            var brightnessSlider = document.getElementById('bell-brightness');

                            // Synthesis Parameters
                            var decayTime = decaySlider ? parseFloat(decaySlider.value) : 2.5;
                            var brightness = brightnessSlider ? parseFloat(brightnessSlider.value) : 0.5;

                            // Bell Frequencies (Inharmonic partials typical of metallic bells)
                            var f1 = freq;                 // Fundamental
                            var f2 = freq * 2.4;           // Minor third (ish)
                            var f3 = freq * 5.95;          // High metallic shine
                            var f4 = freq * 8.2;           // High shimmer

                            // Gains based on brightness
                            var g1 = 0.5;                  // Fundamental
                            var g2 = 0.3 * brightness;     // Partial 2
                            var g3 = 0.2 * brightness;     // Partial 3
                            var g4 = 0.1 * brightness;     // Partial 4

                            // Create Oscillators
                            var osc1 = audioContext.createOscillator();
                            var osc2 = audioContext.createOscillator();
                            var osc3 = audioContext.createOscillator();
                            var osc4 = audioContext.createOscillator();

                            // Gain Nodes (Volume envelopes)
                            var gain1 = audioContext.createGain();
                            var gain2 = audioContext.createGain();
                            var gain3 = audioContext.createGain();
                            var gain4 = audioContext.createGain();

                            // Master Gain for this note (to control stopNote)
                            var masterGain = audioContext.createGain();
                            masterGain.gain.value = 0.8;

                            osc1.frequency.value = f1;
                            osc2.frequency.value = f2;
                            osc3.frequency.value = f3;
                            osc4.frequency.value = f4;

                            osc1.type = 'sine';
                            osc2.type = 'sine';
                            osc3.type = 'sine';
                            osc4.type = 'sine';

                            // Envelopes
                            gain1.gain.setValueAtTime(0, now);
                            gain1.gain.linearRampToValueAtTime(g1, now + 0.01);
                            gain1.gain.exponentialRampToValueAtTime(0.001, now + decayTime);

                            gain2.gain.setValueAtTime(0, now);
                            gain2.gain.linearRampToValueAtTime(g2, now + 0.01);
                            gain2.gain.exponentialRampToValueAtTime(0.001, now + (decayTime * 0.8));

                            gain3.gain.setValueAtTime(0, now);
                            gain3.gain.linearRampToValueAtTime(g3, now + 0.01);
                            gain3.gain.exponentialRampToValueAtTime(0.001, now + (decayTime * 0.6));

                            gain4.gain.setValueAtTime(0, now);
                            gain4.gain.linearRampToValueAtTime(g4, now + 0.01);
                            gain4.gain.exponentialRampToValueAtTime(0.001, now + (decayTime * 0.4));

                            // Connections
                            osc1.connect(gain1);
                            osc2.connect(gain2);
                            osc3.connect(gain3);
                            osc4.connect(gain4);

                            gain1.connect(masterGain);
                            gain2.connect(masterGain);
                            gain3.connect(masterGain);
                            gain4.connect(masterGain);

                            masterGain.connect(mainGainNode);

                            osc1.start(now);
                            osc2.start(now);
                            osc3.start(now);
                            osc4.start(now);

                            // Auto-stop logic for bell (it naturally decays)
                            osc1.stop(now + decayTime + 0.1);
                            osc2.stop(now + decayTime + 0.1);
                            osc3.stop(now + decayTime + 0.1);
                            osc4.stop(now + decayTime + 0.1);

                            activeOscillators[note] = {
                                masterGain: masterGain,
                                oscillators: [osc1, osc2, osc3, osc4]
                            };

                        } catch (e) {
                            console.error("Error playing bell note:", e);
                        }
                    };

                    inst.stopNote = function(note) {
                        var oscillatorData = activeOscillators[note];
                        if (!oscillatorData) return;

                        try {
                            var now = audioContext.currentTime;
                            var releaseTime = 0.05;

                            if (oscillatorData.masterGain) {
                                oscillatorData.masterGain.gain.cancelScheduledValues(now);
                                oscillatorData.masterGain.gain.setValueAtTime(oscillatorData.masterGain.gain.value, now);
                                oscillatorData.masterGain.gain.linearRampToValueAtTime(0, now + releaseTime);
                            }

                            // Stop all oscillators
                            if (oscillatorData.oscillators) {
                                oscillatorData.oscillators.forEach(function(osc) {
                                    osc.stop(now + releaseTime);
                                });
                            }

                            delete activeOscillators[note];
                        } catch (e) {
                            console.error("Error stopping bell note:", e);
                            delete activeOscillators[note];
                        }
                    };

                    inst.render = function(context, noteData, startTime, duration, destination) {
                        var decaySlider = document.getElementById('bell-decay');
                        var brightnessSlider = document.getElementById('bell-brightness');

                        var decayTime = decaySlider ? parseFloat(decaySlider.value) : 2.5;
                        var brightness = brightnessSlider ? parseFloat(brightnessSlider.value) : 0.5;

                        var freq = noteData.freq;

                        var g1 = 0.5;
                        var g2 = 0.3 * brightness;
                        var g3 = 0.2 * brightness;
                        var g4 = 0.1 * brightness;

                        var partials = [
                            { f: freq, g: g1 },
                            { f: freq * 2.4, g: g2 },
                            { f: freq * 5.95, g: g3 },
                            { f: freq * 8.2, g: g4 }
                        ];

                        var masterGain = context.createGain();
                        masterGain.gain.value = 0.8;
                        masterGain.connect(destination);

                        for(var i=0; i<partials.length; i++) {
                            var osc = context.createOscillator();
                            var gain = context.createGain();

                            osc.type = 'sine';
                            osc.frequency.value = partials[i].f;

                            gain.gain.setValueAtTime(0, startTime);
                            gain.gain.linearRampToValueAtTime(partials[i].g, startTime + 0.01);
                            gain.gain.exponentialRampToValueAtTime(0.001, startTime + (decayTime * (1 - i*0.1)));

                            osc.connect(gain);
                            gain.connect(masterGain);

                            osc.start(startTime);
                            osc.stop(startTime + decayTime + 0.1);
                        }
                    };

                    inst.cleanup = function() {
                        document.body.classList.remove('bell-theme');
                        removeBellControls();
                    };

                    return inst;
                }
            };

            
            var FluteInstrument = {
                create: function() {
                    var inst = InstrumentFactory.create('Flute');
                    
                    inst.init = function() {
                        document.body.classList.add('flute-theme');
                        createFluteControls();
                    };
                    
                    inst.playNote = function(note, freq) {
                        try {
                            var now = audioContext.currentTime;
                                                
                            // FIX: Ensure mainGainNode is initialized
                            if (!mainGainNode || mainGainNode.context !== audioContext) {
                                if (!audioContext) return; 
                                mainGainNode = audioContext.createGain();
                                mainGainNode.gain.value = volumeSlider ? volumeSlider.value : 0.5;
                                mainGainNode.connect(audioContext.destination);
                            }
                            
                            var breathSlider = document.getElementById('flute-breath');
                            var vibratoSlider = document.getElementById('flute-vibrato');
                            
                            var breathAmount = breathSlider ? parseFloat(breathSlider.value) : 0.1;
                            var vibratoSpeed = vibratoSlider ? parseFloat(vibratoSlider.value) : 5;

                            // 1. Main Oscillator (Triangle wave for woodwind tone)
                            var osc = audioContext.createOscillator();
                            osc.type = 'triangle';
                            osc.frequency.setValueAtTime(freq, now);
                            
                            // 2. Vibrato (LFO modulating frequency)
                            var lfo = null;
                            var lfoGain = null;
                            if (vibratoSpeed > 0) {
                                lfo = audioContext.createOscillator();
                                lfo.type = 'sine';
                                lfo.frequency.value = vibratoSpeed;
                                
                                lfoGain = audioContext.createGain();
                                lfoGain.gain.value = 3; // Depth of vibrato in Hz
                                
                                lfo.connect(lfoGain);
                                lfoGain.connect(osc.frequency);
                                lfo.start(now);
                            }

                            // 3. Breath Noise (High passed white noise at attack)
                            var noiseNode = null;
                            var noiseFilter = null;
                            var noiseGain = null;
                            
                            if (breathAmount > 0) {
                                noiseNode = audioContext.createBufferSource();
                                var bufferSize = audioContext.sampleRate * 2;
                                var buffer = audioContext.createBuffer(1, bufferSize, audioContext.sampleRate);
                                var data = buffer.getChannelData(0);
                                for (var i = 0; i < bufferSize; i++) {
                                    data[i] = Math.random() * 2 - 1;
                                }
                                noiseNode.buffer = buffer;
                                noiseNode.loop = true;
                                
                                noiseFilter = audioContext.createBiquadFilter();
                                noiseFilter.type = 'highpass';
                                noiseFilter.frequency.value = 1000;
                                
                                noiseGain = audioContext.createGain();
                                noiseGain.gain.setValueAtTime(breathAmount, now);
                                noiseGain.gain.exponentialRampToValueAtTime(0.001, now + 0.3); // Short burst of breath
                                
                                noiseNode.connect(noiseFilter);
                                noiseFilter.connect(noiseGain);
                                noiseGain.connect(mainGainNode);
                                noiseNode.start(now);
                                // NOTE: We do not stop noiseNode here, we handle it in stopNote
                            }

                            // 4. Main Gain (Envelope)
                            var mainGain = audioContext.createGain();
                            mainGain.gain.setValueAtTime(0, now);
                            mainGain.gain.linearRampToValueAtTime(0.3, now + 0.1); // Attack
                            mainGain.gain.linearRampToValueAtTime(0.25, now + 0.2); // Slight dip
                            mainGain.gain.linearRampToValueAtTime(0.3, now + 0.4); // Sustain

                            osc.connect(mainGain);
                            mainGain.connect(mainGainNode);
                            osc.start(now);

                            // FIX: Store noiseNode so we can stop it later
                            activeOscillators[note] = {
                                osc: osc,
                                mainGain: mainGain,
                                lfo: lfo,
                                lfoGain: lfoGain,
                                noiseNode: noiseNode // Added this reference
                            };

                        } catch (e) {
                            console.error("Error playing flute note:", e);
                        }
                    };

                    inst.stopNote = function(note) {
                        var oscillatorData = activeOscillators[note];
                        if (!oscillatorData) return;
                        
                        try {
                            var now = audioContext.currentTime;
                            var releaseTime = 0.3;
                            
                            // Stop LFO
                            if (oscillatorData.lfo) {
                                oscillatorData.lfo.stop(now + releaseTime);
                            }

                            // FIX: Stop the noise node to prevent memory leak
                            if (oscillatorData.noiseNode) {
                                try {
                                    oscillatorData.noiseNode.stop(now + releaseTime);
                                } catch(e) {}
                            }

                            if (oscillatorData.mainGain) {
                                oscillatorData.mainGain.gain.cancelScheduledValues(now);
                                oscillatorData.mainGain.gain.setValueAtTime(oscillatorData.mainGain.gain.value, now);
                                oscillatorData.mainGain.gain.exponentialRampToValueAtTime(0.001, now + releaseTime);
                                
                                // Stop oscillator after release
                                oscillatorData.osc.stop(now + releaseTime);
                            }
                            
                            delete activeOscillators[note];
                        } catch (e) {
                            console.error("Error stopping flute note:", e);
                            delete activeOscillators[note];
                        }
                    };

                    // Keep existing export and cleanup methods...
                    inst.render = function(context, noteData, startTime, duration, destination) {
                        var breathSlider = document.getElementById('flute-breath');
                        var vibratoSlider = document.getElementById('flute-vibrato');
                        
                        var breathAmount = breathSlider ? parseFloat(breathSlider.value) : 0.1;
                        var vibratoSpeed = vibratoSlider ? parseFloat(vibratoSlider.value) : 5;
                        var freq = noteData.freq;

                        // 1. Main Osc
                        var osc = context.createOscillator();
                        osc.type = 'triangle';
                        osc.frequency.setValueAtTime(freq, startTime);
                        
                        // 2. Vibrato
                        if (vibratoSpeed > 0) {
                            var lfo = context.createOscillator();
                            lfo.type = 'sine';
                            lfo.frequency.value = vibratoSpeed;
                            var lfoGain = context.createGain();
                            lfoGain.gain.value = 3;
                            lfo.connect(lfoGain);
                            lfoGain.connect(osc.frequency);
                            lfo.start(startTime);
                            lfo.stop(startTime + duration + 0.5);
                        }

                        // 3. Breath
                        if (breathAmount > 0) {
                            var noiseNode = context.createBufferSource();
                            var bufferSize = context.sampleRate * 0.5;
                            var buffer = context.createBuffer(1, bufferSize, context.sampleRate);
                            var data = buffer.getChannelData(0);
                            for (var i = 0; i < bufferSize; i++) {
                                data[i] = Math.random() * 2 - 1;
                            }
                            noiseNode.buffer = buffer;
                            noiseNode.loop = true;
                            
                            var noiseFilter = context.createBiquadFilter();
                            noiseFilter.type = 'highpass';
                            noiseFilter.frequency.value = 1000;
                            
                            var noiseGain = context.createGain();
                            noiseGain.gain.setValueAtTime(breathAmount, startTime);
                            noiseGain.gain.exponentialRampToValueAtTime(0.001, startTime + 0.3);
                            
                            noiseNode.connect(noiseFilter);
                            noiseFilter.connect(noiseGain);
                            noiseGain.connect(destination);
                            noiseNode.start(startTime);
                            noiseNode.stop(startTime + 0.5);
                        }

                        // 4. Envelope
                        var mainGain = context.createGain();
                        mainGain.gain.setValueAtTime(0, startTime);
                        mainGain.gain.linearRampToValueAtTime(0.3, startTime + 0.1);
                        mainGain.gain.linearRampToValueAtTime(0.25, startTime + 0.2);
                        mainGain.gain.linearRampToValueAtTime(0.3, startTime + 0.4);
                        
                        // Release
                        var releaseTime = 0.3;
                        mainGain.gain.setValueAtTime(0.3, startTime + duration);
                        mainGain.gain.exponentialRampToValueAtTime(0.001, startTime + duration + releaseTime);

                        osc.connect(mainGain);
                        mainGain.connect(destination);
                        osc.start(startTime);
                        osc.stop(startTime + duration + releaseTime);
                    };
                    
                    inst.cleanup = function() {
                        document.body.classList.remove('flute-theme');
                        removeFluteControls();
                    };

                    return inst;
                }
            };
            
            var ViolinInstrument = {
                create: function() {
                    var inst = InstrumentFactory.create('Violin');
                    
                    inst.init = function() {
                        document.body.classList.add('violin-theme');
                        createViolinControls();
                    };
                    
                    inst.playNote = function(note, freq) {
                        try {
                            var now = audioContext.currentTime;
                                                
                            // FIX: Ensure mainGainNode is initialized
                            if (!mainGainNode || mainGainNode.context !== audioContext) {
                                if (!audioContext) return; 
                                mainGainNode = audioContext.createGain();
                                mainGainNode.gain.value = volumeSlider ? volumeSlider.value : 0.5;
                                mainGainNode.connect(audioContext.destination);
                            }
                            
                            var attackSlider = document.getElementById('violin-attack');
                            var vibratoSlider = document.getElementById('violin-vibrato');
                            var filterSlider = document.getElementById('violin-filter');

                            var attackTime = attackSlider ? parseFloat(attackSlider.value) : 0.2;
                            var vibratoRate = vibratoSlider ? parseFloat(vibratoSlider.value) : 6;
                            var filterFreq = filterSlider ? parseFloat(filterSlider.value) : 2500;

                            // 1. Oscillator (Sawtooth for string buzz)
                            var osc = audioContext.createOscillator();
                            osc.type = 'sawtooth';
                            osc.frequency.setValueAtTime(freq, now);
                            osc.start(now); // Start immediately to ensure state validity

                            // 2. Vibrato (LFO)
                            var lfo = null;
                            var lfoGain = null;
                            if (vibratoRate > 0) {
                                lfo = audioContext.createOscillator();
                                lfo.type = 'sine';
                                lfo.frequency.value = vibratoRate;
                                
                                lfoGain = audioContext.createGain();
                                lfoGain.gain.value = 8; // Depth in Hz

                                lfo.connect(lfoGain);
                                lfoGain.connect(osc.frequency);
                                lfo.start(now); // Start immediately
                            }

                            // 3. Filter (Lowpass to warm sawtooth)
                            var filter = audioContext.createBiquadFilter();
                            filter.type = 'lowpass';
                            filter.frequency.value = filterFreq;
                            filter.Q.value = 1;

                            // 4. Reverb (Simple Convolver for room sound)
                            var convolver = audioContext.createConvolver();
                            var reverbGain = audioContext.createGain();
                            var dryGain = audioContext.createGain();
                            
                            // Generate impulse
                            var length = audioContext.sampleRate * 1.5;
                            var impulse = audioContext.createBuffer(2, length, audioContext.sampleRate);
                            for (var channel = 0; channel < 2; channel++) {
                                var channelData = impulse.getChannelData(channel);
                                for (var i = 0; i < length; i++) {
                                    channelData[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / length, 2);
                                }
                            }
                            convolver.buffer = impulse;
                            
                            reverbGain.gain.value = 0.4; // Mix amount
                            dryGain.gain.value = 0.6;

                            osc.connect(filter);
                            filter.connect(dryGain);
                            filter.connect(reverbGain);
                            
                            dryGain.connect(mainGainNode);
                            reverbGain.connect(convolver);
                            convolver.connect(mainGainNode);

                            // 5. Envelope
                            var masterGain = audioContext.createGain();
                            masterGain.gain.setValueAtTime(0, now);
                            // Slow bowing attack
                            masterGain.gain.linearRampToValueAtTime(0.4, now + attackTime);
                            
                            // Insert master gain at start of chain
                            osc.disconnect(); 
                            osc.connect(masterGain);
                            masterGain.connect(filter);

                            activeOscillators[note] = {
                                osc: osc,
                                masterGain: masterGain,
                                lfo: lfo,
                                lfoGain: lfoGain
                            };

                        } catch (e) {
                            console.error("Error playing violin note:", e);
                            // Cleanup locally if start failed
                            try { if(osc) osc.stop(); } catch(e){}
                        }
                    };

                    inst.stopNote = function(note) {
                        var oscillatorData = activeOscillators[note];
                        if (!oscillatorData) return;
                        
                        // Prevent re-entry logic
                        if (oscillatorData.isStopping) return;
                        oscillatorData.isStopping = true;

                        try {
                            var now = audioContext.currentTime;
                            var releaseTime = 0.4;
                            
                            // DEFENSIVE: Wrap stop calls in try/catch
                            // This prevents the "Can't call stop() without calling start()" crash
                            // if the Web Audio node is in a transient bad state.
                            
                            try {
                                if (oscillatorData.lfo) {
                                    oscillatorData.lfo.stop(now + releaseTime);
                                }
                            } catch (e) {
                                // Ignore node stop errors
                            }

                            if (oscillatorData.masterGain) {
                                oscillatorData.masterGain.gain.cancelScheduledValues(now);
                                oscillatorData.masterGain.gain.setValueAtTime(oscillatorData.masterGain.gain.value, now);
                                oscillatorData.masterGain.gain.exponentialRampToValueAtTime(0.001, now + releaseTime);
                                
                                try {
                                    oscillatorData.osc.stop(now + releaseTime);
                                } catch (e) {
                                    // Ignore node stop errors
                                }
                            }
                            
                            // Safe cleanup delay
                            setTimeout(function() {
                                if (activeOscillators[note] && activeOscillators[note].isStopping) {
                                    delete activeOscillators[note];
                                    hideKeyPress(note);
                                }
                            }, releaseTime * 1000);

                        } catch (e) {
                            console.error("Error stopping violin note:", e);
                            // Force delete if logic crashes
                            delete activeOscillators[note];
                            hideKeyPress(note);
                        }
                    };

                    inst.render = function(context, noteData, startTime, duration, destination) {
                        var attackSlider = document.getElementById('violin-attack');
                        var vibratoSlider = document.getElementById('violin-vibrato');
                        var filterSlider = document.getElementById('violin-filter');

                        var attackTime = attackSlider ? parseFloat(attackSlider.value) : 0.2;
                        var vibratoRate = vibratoSlider ? parseFloat(vibratoSlider.value) : 6;
                        var filterFreq = filterSlider ? parseFloat(filterSlider.value) : 2500;
                        var freq = noteData.freq;

                        // 1. Oscillator (Sawtooth for string buzz)
                        var osc = context.createOscillator();
                        osc.type = 'sawtooth';
                        osc.frequency.setValueAtTime(freq, startTime);

                        // 2. Vibrato (LFO)
                        if (vibratoRate > 0) {
                            var lfo = context.createOscillator();
                            lfo.type = 'sine';
                            lfo.frequency.value = vibratoRate;
                            var lfoGain = context.createGain();
                            lfoGain.gain.value = 8; // Depth in Hz
                            lfo.connect(lfoGain);
                            lfoGain.connect(osc.frequency);
                            lfo.start(startTime);
                            lfo.stop(startTime + duration + 0.5);
                        }

                        // 3. Filter (Lowpass to warm sawtooth)
                        var filter = context.createBiquadFilter();
                        filter.type = 'lowpass';
                        filter.frequency.value = filterFreq;
                        filter.Q.value = 1;

                        // 4. Reverb (Simple Convolver for room sound)
                        var convolver = context.createConvolver();
                        var reverbGain = context.createGain();
                        var dryGain = context.createGain();
                        
                        // Generate impulse
                        var length = context.sampleRate * 1.5;
                        var impulse = context.createBuffer(2, length, context.sampleRate);
                        for (var channel = 0; channel < 2; channel++) {
                            var channelData = impulse.getChannelData(channel);
                            for (var i = 0; i < length; i++) {
                                channelData[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / length, 2);
                            }
                        }
                        convolver.buffer = impulse;
                        
                        reverbGain.gain.value = 0.4; // Mix amount
                        dryGain.gain.value = 0.6;

                        osc.connect(filter);
                        filter.connect(dryGain);
                        filter.connect(reverbGain);
                        
                        dryGain.connect(destination);
                        reverbGain.connect(convolver);
                        convolver.connect(destination);

                        // 5. Envelope
                        var masterGain = context.createGain();
                        masterGain.gain.setValueAtTime(0, startTime);
                        // Slow bowing attack
                        masterGain.gain.linearRampToValueAtTime(0.4, startTime + attackTime);
                        
                        var releaseTime = 0.4;

                        masterGain.gain.setValueAtTime(0.4, startTime + duration);
                        masterGain.gain.exponentialRampToValueAtTime(0.001, startTime + duration + releaseTime);

                        // Insert master gain at start of chain
                        osc.disconnect(); 
                        osc.connect(masterGain);
                        masterGain.connect(filter);

                        osc.start(startTime);
                        osc.stop(startTime + duration + releaseTime);
                    };
                    
                    inst.cleanup = function() {
                        document.body.classList.remove('violin-theme');
                        removeViolinControls();
                    };

                    return inst;
                }
            };
            
            var UkuleleInstrument = {
                create: function() {
                    var inst = InstrumentFactory.create('Ukulele');
                    
                    inst.init = function() {
                        document.body.classList.add('ukulele-theme');
                        createUkuleleControls();
                    };
                    
                    inst.playNote = function(note, freq) {
                        try {
                            var now = audioContext.currentTime;
                                                
                            // FIX: Ensure mainGainNode is initialized
                            if (!mainGainNode || mainGainNode.context !== audioContext) {
                                if (!audioContext) return; 
                                mainGainNode = audioContext.createGain();
                                mainGainNode.gain.value = volumeSlider ? volumeSlider.value : 0.5;
                                mainGainNode.connect(audioContext.destination);
                            }
                            
                            var decaySlider = document.getElementById('ukulele-decay');
                            var nylonSlider = document.getElementById('ukulele-nylon');

                            var decayTime = decaySlider ? parseFloat(decaySlider.value) : 0.8;
                            var nylonFactor = nylonSlider ? parseFloat(nylonSlider.value) : 4;

                            // 1. Oscillator (Sawtooth for string texture)
                            var osc = audioContext.createOscillator();
                            osc.type = 'sawtooth';
                            osc.frequency.setValueAtTime(freq, now);
                            osc.start(now); 

                            // 2. Harmonics (Body resonance)
                            var harmonic1 = audioContext.createOscillator();
                            harmonic1.type = 'sine';
                            harmonic1.frequency.setValueAtTime(freq * 2.5, now);
                            harmonic1.start(now);

                            var h1Gain = audioContext.createGain();
                            h1Gain.gain.value = 0.1;

                            // 3. Filter (Lowpass)
                            var filter = audioContext.createBiquadFilter();
                            filter.type = 'lowpass';
                            filter.frequency.value = freq * nylonFactor;
                            filter.Q.value = 1.5;

                            // 4. Pluck Noise (Transient)
                            var pluckNoise = audioContext.createBufferSource();
                            var pluckBuffer = audioContext.createBuffer(1, audioContext.sampleRate * 0.05, audioContext.sampleRate);
                            var pluckData = pluckBuffer.getChannelData(0);
                            for (var i = 0; i < pluckBuffer.length; i++) {
                                pluckData[i] = (Math.random() * 2 - 1) * 0.3;
                            }
                            pluckNoise.buffer = pluckBuffer;
                            
                            var pluckGain = audioContext.createGain();
                            pluckNoise.connect(pluckGain);
                            pluckGain.connect(filter);
                            pluckNoise.start(now);
                            // pluckNoise.stop is handled in stopNote

                            // Pluck envelope
                            pluckGain.gain.setValueAtTime(0.2, now);
                            pluckGain.gain.exponentialRampToValueAtTime(0.01, now + 0.05);

                            // 5. Main Envelope
                            var masterGain = audioContext.createGain();
                            
                            osc.connect(masterGain);
                            harmonic1.connect(h1Gain);
                            h1Gain.connect(masterGain);
                            
                            masterGain.connect(filter);
                            filter.connect(mainGainNode);

                            masterGain.gain.setValueAtTime(0, now);
                            masterGain.gain.linearRampToValueAtTime(0.4, now + 0.02);
                            masterGain.gain.exponentialRampToValueAtTime(0.001, now + decayTime);

                            // FIX: Store pluckNoise so we can stop it later
                            activeOscillators[note] = {
                                osc: osc,
                                harmonic1: harmonic1,
                                masterGain: masterGain,
                                pluckNoise: pluckNoise // Added reference
                            };

                        } catch (e) {
                            console.error("Error playing ukulele note:", e);
                        }
                    };

                    inst.stopNote = function(note) {
                        var oscillatorData = activeOscillators[note];
                        if (!oscillatorData) return;

                        // Prevent re-entry
                        if (oscillatorData.isStopping) return;
                        oscillatorData.isStopping = true;

                        try {
                            var now = audioContext.currentTime;
                            var releaseTime = 0.1;

                            // Stop Oscillators
                            try {
                                if (oscillatorData.osc) oscillatorData.osc.stop(now + releaseTime);
                                if (oscillatorData.harmonic1) oscillatorData.harmonic1.stop(now + releaseTime);
                            } catch (e) {
                                // Ignore stop errors
                            }

                            // FIX: Stop Pluck Noise to prevent memory leak
                            if (oscillatorData.pluckNoise) {
                                try {
                                    oscillatorData.pluckNoise.stop(now + releaseTime);
                                } catch (e) {}
                            }

                            if (oscillatorData.masterGain) {
                                oscillatorData.masterGain.gain.cancelScheduledValues(now);
                                oscillatorData.masterGain.gain.setValueAtTime(oscillatorData.masterGain.gain.value, now);
                                oscillatorData.masterGain.gain.exponentialRampToValueAtTime(0.001, now + releaseTime);
                            }

                            // FIX: Use equality check to prevent Race Condition.
                            // If a new note starts, it overwrites activeOscillators[note].
                            // We must ensure we don't delete the NEW note when the OLD note's timeout fires.
                            setTimeout(function() {
                                if (activeOscillators[note] === oscillatorData) {
                                    delete activeOscillators[note];
                                    hideKeyPress(note);
                                }
                            }, releaseTime * 1000);

                        } catch (e) {
                            console.error("Error stopping ukulele note:", e);
                            delete activeOscillators[note];
                            hideKeyPress(note);
                        }
                    };

                    inst.render = function(context, noteData, startTime, duration, destination) {
                        var decaySlider = document.getElementById('ukulele-decay');
                        var nylonSlider = document.getElementById('ukulele-nylon');

                        var decayTime = decaySlider ? parseFloat(decaySlider.value) : 0.8;
                        var nylonFactor = nylonSlider ? parseFloat(nylonSlider.value) : 4;
                        var freq = noteData.freq;

                        var osc = context.createOscillator();
                        osc.type = 'sawtooth';
                        osc.frequency.value = freq;

                        var harmonic1 = context.createOscillator();
                        harmonic1.type = 'sine';
                        harmonic1.frequency.value = freq * 2.5;
                        var h1Gain = context.createGain();
                        h1Gain.gain.value = 0.1;

                        var filter = context.createBiquadFilter();
                        filter.type = 'lowpass';
                        filter.frequency.value = freq * nylonFactor;
                        filter.Q.value = 1.5;

                        var masterGain = context.createGain();
                        
                        osc.connect(masterGain);
                        harmonic1.connect(h1Gain);
                        h1Gain.connect(masterGain);
                        masterGain.connect(filter);
                        filter.connect(destination);

                        var releaseTime = 0.1;

                        masterGain.gain.setValueAtTime(0, startTime);
                        masterGain.gain.linearRampToValueAtTime(0.4, startTime + 0.02);
                        masterGain.gain.setValueAtTime(0.4, startTime + duration);
                        masterGain.gain.exponentialRampToValueAtTime(0.001, startTime + duration + releaseTime);

                        osc.start(startTime);
                        harmonic1.start(startTime);
                        osc.stop(startTime + duration + releaseTime);
                        harmonic1.stop(startTime + duration + releaseTime);
                    };
                    
                    inst.cleanup = function() {
                        document.body.classList.remove('ukulele-theme');
                        removeUkuleleControls();
                    };

                    return inst;
                }
            };
            
            var TubaInstrument = {
                create: function() {
                    var inst = InstrumentFactory.create('Tuba');
                    
                    inst.init = function() {
                        document.body.classList.add('tuba-theme');
                        createTubaControls();
                    };
                    
                    inst.playNote = function(note, freq) {
                        try {
                            var now = audioContext.currentTime;
                                                
                            // FIX: Ensure mainGainNode is initialized
                            if (!mainGainNode || mainGainNode.context !== audioContext) {
                                if (!audioContext) return; 
                                mainGainNode = audioContext.createGain();
                                mainGainNode.gain.value = volumeSlider ? volumeSlider.value : 0.5;
                                mainGainNode.connect(audioContext.destination);
                            }
                            
                            var attackSlider = document.getElementById('tuba-attack');
                            var releaseSlider = document.getElementById('tuba-release');
                            var brillSlider = document.getElementById('tuba-brilliance');
                            var vibSlider = document.getElementById('tuba-vibrato');

                            var attackTime = attackSlider ? parseFloat(attackSlider.value) : 0.2;
                            var releaseTime = releaseSlider ? parseFloat(releaseSlider.value) : 0.4;
                            var brilliance = brillSlider ? parseFloat(brillSlider.value) : 2.5;
                            var vibRate = vibSlider ? parseFloat(vibSlider.value) : 4.0;

                            // 1. Oscillators (Sawtooth for Brass)
                            // We use two slightly detuned sawtooths for thickness
                            var osc1 = audioContext.createOscillator();
                            osc1.type = 'sawtooth';
                            osc1.frequency.setValueAtTime(freq, now);
                            osc1.start(now);

                            var osc2 = audioContext.createOscillator();
                            osc2.type = 'sawtooth';
                            osc2.frequency.setValueAtTime(freq * 1.005, now); // Slight detune
                            osc2.start(now);

                            // 2. Vibrato (LFO)
                            var lfo = audioContext.createOscillator();
                            lfo.type = 'sine';
                            lfo.frequency.value = vibRate;
                            var lfoGain = audioContext.createGain();
                            lfoGain.gain.value = 6; // Depth in Hz

                            lfo.connect(lfoGain);
                            lfoGain.connect(osc1.frequency);
                            lfoGain.connect(osc2.frequency);
                            lfo.start(now);

                            // 3. Filter (Lowpass is essential for Tuba sound)
                            var filter = audioContext.createBiquadFilter();
                            filter.type = 'lowpass';
                            filter.frequency.value = freq * brilliance;
                            filter.Q.value = 1.0;

                            // 4. Mixers/Gains
                            var osc1Gain = audioContext.createGain();
                            osc1Gain.gain.value = 0.5;
                            var osc2Gain = audioContext.createGain();
                            osc2Gain.gain.value = 0.5;

                            osc1.connect(osc1Gain);
                            osc2.connect(osc2Gain);
                            osc1Gain.connect(filter);
                            osc2Gain.connect(filter);

                            // 5. Main Envelope
                            var masterGain = audioContext.createGain();
                            
                            filter.connect(masterGain);
                            masterGain.connect(mainGainNode);

                            masterGain.gain.setValueAtTime(0, now);
                            // Slow, swelling attack
                            masterGain.gain.linearRampToValueAtTime(0.5, now + attackTime);

                            activeOscillators[note] = {
                                osc1: osc1,
                                osc2: osc2,
                                lfo: lfo,
                                masterGain: masterGain,
                                releaseTime: releaseTime
                            };

                        } catch (e) {
                            console.error("Error playing tuba note:", e);
                        }
                    };

                    inst.stopNote = function(note) {
                        var oscillatorData = activeOscillators[note];
                        if (!oscillatorData) return;

                        // Prevent re-entry
                        if (oscillatorData.isStopping) return;
                        oscillatorData.isStopping = true;

                        try {
                            var now = audioContext.currentTime;
                            var releaseTime = oscillatorData.releaseTime || 0.4;

                            try {
                                if (oscillatorData.osc1) oscillatorData.osc1.stop(now + releaseTime);
                                if (oscillatorData.osc2) oscillatorData.osc2.stop(now + releaseTime);
                                if (oscillatorData.lfo) oscillatorData.lfo.stop(now + releaseTime);
                            } catch (e) {}

                            if (oscillatorData.masterGain) {
                                oscillatorData.masterGain.gain.cancelScheduledValues(now);
                                oscillatorData.masterGain.gain.setValueAtTime(oscillatorData.masterGain.gain.value, now);
                                oscillatorData.masterGain.gain.exponentialRampToValueAtTime(0.001, now + releaseTime);
                            }

                            // Safe cleanup delay
                            setTimeout(function() {
                                if (activeOscillators[note] && activeOscillators[note].isStopping) {
                                    delete activeOscillators[note];
                                    hideKeyPress(note);
                                }
                            }, releaseTime * 1000);

                        } catch (e) {
                            console.error("Error stopping tuba note:", e);
                            delete activeOscillators[note];
                            hideKeyPress(note);
                        }
                    };

                    inst.render = function(context, noteData, startTime, duration, destination) {
                        var attackSlider = document.getElementById('tuba-attack');
                        var releaseSlider = document.getElementById('tuba-release');
                        var brillSlider = document.getElementById('tuba-brilliance');
                        var vibSlider = document.getElementById('tuba-vibrato');

                        var attackTime = attackSlider ? parseFloat(attackSlider.value) : 0.2;
                        var releaseTime = releaseSlider ? parseFloat(releaseSlider.value) : 0.4;
                        var brilliance = brillSlider ? parseFloat(brillSlider.value) : 2.5;
                        var vibRate = vibSlider ? parseFloat(vibSlider.value) : 4.0;
                        var freq = noteData.freq;

                        var osc1 = context.createOscillator();
                        osc1.type = 'sawtooth';
                        osc1.frequency.setValueAtTime(freq, startTime);

                        var osc2 = context.createOscillator();
                        osc2.type = 'sawtooth';
                        osc2.frequency.setValueAtTime(freq * 1.005, startTime);

                        var lfo = context.createOscillator();
                        lfo.type = 'sine';
                        lfo.frequency.value = vibRate;
                        var lfoGain = context.createGain();
                        lfoGain.gain.value = 6;
                        lfo.connect(lfoGain);
                        lfoGain.connect(osc1.frequency);
                        lfoGain.connect(osc2.frequency);
                        lfo.start(startTime);
                        lfo.stop(startTime + duration + releaseTime);

                        var filter = context.createBiquadFilter();
                        filter.type = 'lowpass';
                        filter.frequency.value = freq * brilliance;
                        filter.Q.value = 1.0;

                        var osc1Gain = context.createGain();
                        osc1Gain.gain.value = 0.5;
                        var osc2Gain = context.createGain();
                        osc2Gain.gain.value = 0.5;
                        
                        var masterGain = context.createGain();

                        osc1.connect(osc1Gain);
                        osc2.connect(osc2Gain);
                        osc1Gain.connect(filter);
                        osc2Gain.connect(filter);
                        filter.connect(masterGain);
                        masterGain.connect(destination);

                        masterGain.gain.setValueAtTime(0, startTime);
                        masterGain.gain.linearRampToValueAtTime(0.5, startTime + attackTime);
                        
                        masterGain.gain.setValueAtTime(0.5, startTime + duration);
                        masterGain.gain.exponentialRampToValueAtTime(0.001, startTime + duration + releaseTime);

                        osc1.start(startTime);
                        osc2.start(startTime);
                        osc1.stop(startTime + duration + releaseTime);
                        osc2.stop(startTime + duration + releaseTime);
                    };
                    
                    inst.cleanup = function() {
                        document.body.classList.remove('tuba-theme');
                        removeTubaControls();
                    };

                    return inst;
                }
            };
            
            var CustomSampleInstrument = {
                create: function() {
                    var inst = InstrumentFactory.create('Custom');
                    
                    inst.init = function() {
                        document.body.classList.add('custom-theme');
                        createCustomControls();
                    };
                    
                    inst.playNote = function(note, freq) {
                        try {
                            if (!window.customSampleBuffer) return;

                            var now = audioContext.currentTime;
                                                
                            // FIX: Ensure mainGainNode is initialized
                            if (!mainGainNode || mainGainNode.context !== audioContext) {
                                if (!audioContext) return; 
                                mainGainNode = audioContext.createGain();
                                mainGainNode.gain.value = volumeSlider ? volumeSlider.value : 0.5;
                                mainGainNode.connect(audioContext.destination);
                            }

                            // 1. Source
                            var source = audioContext.createBufferSource();
                            source.buffer = window.customSampleBuffer;
                            source.loop = true; // Loop while holding key

                            // 2. Pitch Shifting
                            // We calculate the playback rate based on the played frequency vs the assumed base frequency (C4)
                            var baseFreq = window.customSampleBaseFreq || 261.626;
                            var playbackRate = freq / baseFreq;
                            source.playbackRate.value = playbackRate;

                            // 3. Envelope (ADSR)
                            var gainNode = audioContext.createGain();
                            
                            source.connect(gainNode);
                            gainNode.connect(mainGainNode);
                            
                            source.start(now);

                            // Simple Attack/Decay simulation
                            gainNode.gain.setValueAtTime(0, now);
                            gainNode.gain.linearRampToValueAtTime(0.8, now + 0.05); // Attack
                            gainNode.gain.linearRampToValueAtTime(0.7, now + 0.2); // Decay to Sustain

                            activeOscillators[note] = {
                                source: source,
                                gainNode: gainNode
                            };

                        } catch (e) {
                            console.error("Error playing custom note:", e);
                        }
                    };

                    inst.stopNote = function(note) {
                        var oscillatorData = activeOscillators[note];
                        if (!oscillatorData) return;

                        if (oscillatorData.isStopping) return;
                        oscillatorData.isStopping = true;

                        try {
                            var now = audioContext.currentTime;
                            var releaseTime = 0.2; // Quick release for samplers

                            if (oscillatorData.gainNode) {
                                oscillatorData.gainNode.gain.cancelScheduledValues(now);
                                oscillatorData.gainNode.gain.setValueAtTime(oscillatorData.gainNode.gain.value, now);
                                oscillatorData.gainNode.gain.exponentialRampToValueAtTime(0.001, now + releaseTime);
                                
                                try {
                                    oscillatorData.source.stop(now + releaseTime);
                                } catch (e) {
                                    // Ignore stop errors
                                }
                            }

                            setTimeout(function() {
                                if (activeOscillators[note] && activeOscillators[note].isStopping) {
                                    delete activeOscillators[note];
                                    hideKeyPress(note);
                                }
                            }, releaseTime * 1000);

                        } catch (e) {
                            console.error("Error stopping custom note:", e);
                            delete activeOscillators[note];
                            hideKeyPress(note);
                        }
                    };

                    inst.render = function(context, noteData, startTime, duration, destination) {
                        if (!window.customSampleBuffer) return;

                        var freq = noteData.freq;
                        var baseFreq = window.customSampleBaseFreq || 261.626;
                        
                        var source = context.createBufferSource();
                        source.buffer = window.customSampleBuffer;
                        source.loop = true;
                        
                        var playbackRate = freq / baseFreq;
                        source.playbackRate.value = playbackRate;

                        var gainNode = context.createGain();
                        
                        source.connect(gainNode);
                        gainNode.connect(destination);

                        var releaseTime = 0.2;
                        
                        gainNode.gain.setValueAtTime(0, startTime);
                        gainNode.gain.linearRampToValueAtTime(0.8, startTime + 0.05);
                        gainNode.gain.linearRampToValueAtTime(0.7, startTime + 0.2);
                        gainNode.gain.setValueAtTime(0.7, startTime + duration);
                        gainNode.gain.exponentialRampToValueAtTime(0.001, startTime + duration + releaseTime);

                        source.start(startTime);
                        source.stop(startTime + duration + releaseTime);
                    };
                    
                    inst.cleanup = function() {
                        document.body.classList.remove('custom-theme');
                        removeCustomControls();
                    };

                    return inst;
                }
            };

            /* --- NOTE DATA (Wicki-Hayden inspired layout) --- */
            var noteLayout = [
                /* Octave 1 */
                { key: '', note: 'C1', freq: 32.703, type: 'white' },
                { key: '', note: 'C#1', freq: 34.648, type: 'black' },
                { key: '', note: 'D1', freq: 36.708, type: 'white' },
                { key: '', note: 'D#1', freq: 38.891, type: 'black' },
                { key: '', note: 'E1', freq: 41.203, type: 'white' },
                { key: '', note: 'F1', freq: 43.654, type: 'white' },
                { key: '', note: 'F#1', freq: 46.249, type: 'black' },
                { key: '', note: 'G1', freq: 49.000, type: 'white' },
                { key: '', note: 'G#1', freq: 51.913, type: 'black' },
                { key: '', note: 'A1', freq: 55.000, type: 'white' },
                { key: '', note: 'A#1', freq: 58.270, type: 'black' },
                { key: '', note: 'B1', freq: 61.735, type: 'white' },

                /* Octave 2 */
                { key: '', note: 'C2', freq: 65.406, type: 'white' },
                { key: '', note: 'C#2', freq: 69.296, type: 'black' },
                { key: '', note: 'D2', freq: 73.416, type: 'white' },
                { key: '', note: 'D#2', freq: 77.782, type: 'black' },
                { key: '', note: 'E2', freq: 82.407, type: 'white' },
                { key: '', note: 'F2', freq: 87.307, type: 'white' },
                { key: '', note: 'F#2', freq: 92.499, type: 'black' },
                { key: '', note: 'G2', freq: 98.000, type: 'white' },
                { key: '', note: 'G#2', freq: 103.826, type: 'black' },
                { key: '', note: 'A2', freq: 110.000, type: 'white' },
                { key: '', note: 'A#2', freq: 116.541, type: 'black' },
                { key: '', note: 'B2', freq: 123.471, type: 'white' },
                
                /* Octave 3 */
                { key: 'z', note: 'C3', freq: 130.813, type: 'white' },
                { key: 'Z', note: 'C#3', freq: 138.591, type: 'black' },
                { key: 'x', note: 'D3', freq: 146.832, type: 'white' },
                { key: 'X', note: 'D#3', freq: 155.563, type: 'black' },
                { key: 'c', note: 'E3', freq: 164.814, type: 'white' },
                { key: 'v', note: 'F3', freq: 174.614, type: 'white' },
                { key: 'V', note: 'F#3', freq: 184.997, type: 'black' },
                { key: 'b', note: 'G3', freq: 196.000, type: 'white' },
                { key: 'B', note: 'G#3', freq: 207.652, type: 'black' },
                { key: 'n', note: 'A3', freq: 220.000, type: 'white' },
                { key: 'N', note: 'A#3', freq: 233.082, type: 'black' },
                { key: 'm', note: 'B3', freq: 246.942, type: 'white' },

                /* Octave 4 (Middle C is C4) */
                { key: 'a', note: 'C4', freq: 261.626, type: 'white' },
                { key: 'A', note: 'C#4', freq: 277.183, type: 'black' },
                { key: 's', note: 'D4', freq: 293.665, type: 'white' },
                { key: 'S', note: 'D#4', freq: 311.127, type: 'black' },
                { key: 'd', note: 'E4', freq: 329.628, type: 'white' },
                { key: 'f', note: 'F4', freq: 349.228, type: 'white' },
                { key: 'F', note: 'F#4', freq: 369.994, type: 'black' },
                { key: 'g', note: 'G4', freq: 392.000, type: 'white' },
                { key: 'G', note: 'G#4', freq: 415.305, type: 'black' },
                { key: 'h', note: 'A4', freq: 440.000, type: 'white' },
                { key: 'H', note: 'A#4', freq: 466.164, type: 'black' },
                { key: 'j', note: 'B4', freq: 493.883, type: 'white' },

                /* Octave 5 */
                { key: 'q', note: 'C5', freq: 523.251, type: 'white' },
                { key: 'Q', note: 'C#5', freq: 554.365, type: 'black' },
                { key: 'w', note: 'D5', freq: 587.330, type: 'white' },
                { key: 'W', note: 'D#5', freq: 622.254, type: 'black' },
                { key: 'e', note: 'E5', freq: 659.255, type: 'white' },
                { key: 'r', note: 'F5', freq: 698.456, type: 'white' },
                { key: 'R', note: 'F#5', freq: 739.989, type: 'black' },
                { key: 't', note: 'G5', freq: 783.991, type: 'white' },
                { key: 'T', note: 'G#5', freq: 830.609, type: 'black' },
                { key: 'y', note: 'A5', freq: 880.000, type: 'white' },
                { key: 'Y', note: 'A#5', freq: 932.328, type: 'black' },
                { key: 'u', note: 'B5', freq: 987.767, type: 'black' },

                /* Octave 6 */
                { key: '1', note: 'C6', freq: 1046.502, type: 'white' },
                { key: '', note: 'C#6', freq: 1108.731, type: 'black' },
                { key: '2', note: 'D6', freq: 1174.659, type: 'white' },
                { key: '', note: 'D#6', freq: 1244.508, type: 'black' },
                { key: '3', note: 'E6', freq: 1318.510, type: 'white' },
                { key: '4', note: 'F6', freq: 1396.913, type: 'white' },
                { key: '', note: 'F#6', freq: 1479.978, type: 'black' },
                { key: '5', note: 'G6', freq: 1567.982, type: 'white' },
                { key: '', note: 'G#6', freq: 1661.219, type: 'black' },
                { key: '6', note: 'A6', freq: 1760.000, type: 'white' },
                { key: '', note: 'A#6', freq: 1864.655, type: 'black' },
                { key: '7', note: 'B6', freq: 1975.533, type: 'white' },

                /* Octave 7 */
                { key: '', note: 'C7', freq: 2093.005, type: 'white' },
                { key: '', note: 'C#7', freq: 2217.461, type: 'black' },
                { key: '', note: 'D7', freq: 2349.318, type: 'white' },
                { key: '', note: 'D#7', freq: 2489.016, type: 'black' },
                { key: '', note: 'E7', freq: 2637.020, type: 'white' },
                { key: '', note: 'F7', freq: 2793.826, type: 'white' },
                { key: '', note: 'F#7', freq: 2959.955, type: 'black' },
                { key: '', note: 'G7', freq: 3135.964, type: 'white' },
                { key: '', note: 'G#7', freq: 3322.438, type: 'black' },
                { key: '', note: 'A7', freq: 3520.000, type: 'white' },
                { key: '', note: 'A#7', freq: 3729.310, type: 'black' },
                { key: '', note: 'B7', freq: 3951.066, type: 'white' }
            ];
                    
            /* 
               Portrait = SHORT or Landscape = WIDE mode
               (from hexano51)
            */
            var SHORT = [
                //noteLayout.slice(0, 6),    /* C1 to F1 */
                //noteLayout.slice(6, 12),   /* F#1 to B1 */
                //noteLayout.slice(12, 18),  /* C2 to F2 */
                //noteLayout.slice(18, 24),  /* F#2 to B2 */
                noteLayout.slice(24, 30),  /* C3 to F3 */
                noteLayout.slice(30, 36),  /* F#3 to B3 */
                noteLayout.slice(36, 42),  /* C4 to F4 */
                noteLayout.slice(42, 48),  /* F#4 to B4 */
                noteLayout.slice(48, 54),  /* C5 to F5 */
                noteLayout.slice(54, 60),  /* F#5 to B5 */
                noteLayout.slice(60, 66),  /* C6 to F6 */
                noteLayout.slice(66, 72),  /* F#6 to B6 */
                //noteLayout.slice(72, 78),  /* C7 to F7 */
                //noteLayout.slice(78, 84)   /* F#7 to B7 */
            ];

            var WIDE = [
                noteLayout.slice(0, 12),   /* C1 to B1 */
                noteLayout.slice(12, 24),  /* C2 to B2 */
                noteLayout.slice(24, 36),  /* C3 to B3 */
                noteLayout.slice(36, 48),  /* C4 to B4 */
                noteLayout.slice(48, 60),  /* C5 to B5 */
                noteLayout.slice(60, 72),  /* C6 to B6 */
                noteLayout.slice(72, 84),  /* C7 to B7 */
            ];

            // Determine default rows based on orientation initially
            var isPortrait = window.innerHeight > window.innerWidth;
            var noteRows = isPortrait ? SHORT : WIDE;
            
            var notesByKey = {};
            var notesByNoteName = {};

            /* --- INITIALIZATION --- */
            function init() {
                createPiano();
                addEventListeners();
                
                /* Initialize instrument selector */
                initInstrumentSelector();
                
                /* Initialize hexboard scaling */
                scaleHexboard();
                window.addEventListener('resize', scaleHexboard);
                window.addEventListener('orientationchange', function() {
                    // Small delay to allow layout to settle before recalculating
                    setTimeout(scaleHexboard, 100); 
                });
            }

            /* --- HEXBOARD SCALING & LAYOUT UPDATE --- */
                        /* --- HEXBOARD SCALING & LAYOUT UPDATE --- */
            function scaleHexboard() {
                if (!hexboard || !hexboardContainer) return;
                
                var svg = hexboard.querySelector('.piano-svg');
                if (!svg) return;

                /* 1. Orientation Check */
                var containerWidth = hexboardContainer.clientWidth;
                var containerHeight = hexboardContainer.clientHeight;
                
                // Determine if we are in portrait mode
                var isPortraitNow = window.innerHeight > window.innerWidth;

                // 2. Rebuild if Layout Changed (e.g., rotated device)
                // Note: In portrait, we use SHORT rows. In landscape, we use WIDE rows.
                var previousRows = noteRows;
                noteRows = isPortraitNow ? SHORT : WIDE;

                // Compare array lengths/contents to detect if we need to redraw
                // We serialize to string for a deep comparison of the structure
                var currentRowsString = JSON.stringify(previousRows);
                var targetRowsString = JSON.stringify(noteRows);

                if (currentRowsString !== targetRowsString) {
                    // Clear existing board
                    while (hexboard.firstChild) {
                        hexboard.removeChild(hexboard.firstChild);
                    }
                    // Reset lookups
                    notesByKey = {};
                    notesByNoteName = {};
                    
                    // Rebuild DOM
                    createPiano();
                    
                    // Re-fetch svg reference as DOM has changed
                    svg = hexboard.querySelector('.piano-svg');
                }

                /* 3. Calculate Dimensions */
                // Get the intrinsic SVG size (from viewBox)
                var viewBox = svg.getAttribute('viewBox').split(' ');
                var svgWidth = parseFloat(viewBox[2]);
                var svgHeight = parseFloat(viewBox[3]);

                if (containerWidth === 0 || containerHeight === 0) return;

                /* 4. Scale Calculation */
                var scale = 1;
                var finalWidth, finalHeight;

                if (isPortraitNow) {
                    // PORTRAIT MODE
                    // In portrait, we effectively rotate the board 90 degrees visually.
                    // This means the SVG's Width should fit into the Container's Height.
                    // And the SVG's Height should fit into the Container's Width.
                    
                    var scaleW = containerHeight / svgWidth;
                    var scaleH = containerWidth / svgHeight;
                    
                    scale = Math.min(scaleW, scaleH);
                    
                    // Set final dimensions such that we swap width and height to match rotation
                    finalWidth = svgHeight * scale;
                    finalHeight = svgWidth * scale;
                    
                    // Remove CSS transforms; we are handling layout via dimensions now
                    hexboard.style.transform = 'none'; 
                } else {
                    // LANDSCAPE MODE
                    // Standard fit: SVG Width to Container Width, SVG Height to Container Height
                    var scaleW = containerWidth / svgWidth;
                    var scaleH = containerHeight / svgHeight;
                    
                    scale = Math.min(scaleW, scaleH);
                    
                    finalWidth = svgWidth * scale;
                    finalHeight = svgHeight * scale;
                    
                    hexboard.style.transform = 'none';
                }

                /* 5. Apply Dimensions */
                // We set the explicit pixel size of the #hexboard div.
                // This allows the flexbox container to center it, and ensures
                // it exactly fits the available space (or maintains aspect ratio).
                hexboard.style.width = finalWidth + 'px';
                hexboard.style.height = finalHeight + 'px';
                
                // Ensure SVG fills the #hexboard div
                svg.style.width = '100%';
                svg.style.height = '100%';

                hexboard.style.transformOrigin = 'center center';
            }

            function initInstrumentSelector() {
                /* Populate instrument dropdown */
                var instrumentList = [
                    { id: 'default', name: 'Default', InstClass: DefaultInstrument },
                    { id: 'gameboy', name: 'Gameboy', InstClass: GameBoyInstrument },
                    { id: 'guitar', name: 'Guitar', InstClass: GuitarInstrument },
                    { id: 'snes', name: 'SNES', InstClass: SNESInstrument },
                    { id: 'drums', name: 'Drums & Percussion', InstClass: DrumsInstrument },
                    { id: 'bell', name: 'Bell', InstClass: BellInstrument },
                    { id: 'flute', name: 'Flute', InstClass: FluteInstrument },
                    { id: 'violin', name: 'Violin', InstClass: ViolinInstrument },
                    { id: 'ukulele', name: 'Ukulele', InstClass: UkuleleInstrument },
                    { id: 'tuba', name: 'Tuba', InstClass: TubaInstrument },
                    { id: 'custom', name: 'Custom Sample', InstClass: CustomSampleInstrument }
                ];

                for (var i = 0; i < instrumentList.length; i++) {
                    var instData = instrumentList[i];
                    var option = document.createElement('div');
                    option.className = 'instrument-option';
                    option.setAttribute('data-instrument', instData.id);
                    option.innerHTML = instData.name;
                    
                    if (instData.id === 'default') {
                        option.classList.add('selected');
                    }
                    
                    option.addEventListener('click', function() {
                        selectInstrument(this.getAttribute('data-instrument'));
                    });
                    
                    instrumentDropdown.appendChild(option);
                }

                // Set default instrument
                //currentInstrumentInstance = new DefaultInstrument();
                currentInstrumentInstance = DefaultInstrument.create();
            }

            function selectInstrument(instrumentId) {
                var ClassMap = { // Renamed from ClassMap to avoid collision logic if minified, though ClassMap is fine as a var
                    'default': DefaultInstrument,
                    'gameboy': GameBoyInstrument,
                    'guitar': GuitarInstrument,
                    'snes': SNESInstrument,
                    'drums': DrumsInstrument,
                    'bell': BellInstrument,
                    'flute': FluteInstrument,
                    'violin': ViolinInstrument,
                    'ukulele': UkuleleInstrument,
                    'tuba': TubaInstrument,
                    'custom': CustomSampleInstrument
                };

                /* Cleanup previous instrument */
                if (currentInstrumentInstance) {
                    currentInstrumentInstance.cleanup();
                }
                
                /* Create new instrument instance using .create() */
                // Use .InstClass instead of .Class
                currentInstrumentInstance = ClassMap[instrumentId].InstClass ? ClassMap[instrumentId].InstClass.create() : ClassMap[instrumentId].create();
                currentInstrumentInstance.init();
                
                /* Update UI */
                var options = instrumentDropdown.querySelectorAll('.instrument-option');
                for (var i = 0; i < options.length; i++) {
                    options[i].classList.remove('selected');
                    if (options[i].getAttribute('data-instrument') === instrumentId) {
                        options[i].classList.add('selected');
                    }
                }
                
                /* Close dropdown */
                instrumentDropdown.classList.remove('active');
            }

            function createGameBoyControls() {
                document.querySelector('.wave-selector').style.display = 'none';
                var controlBar = document.querySelector('.control-bar');
                
                var gameboyControls = document.createElement('div');
                gameboyControls.id = 'gameboy-controls';
                gameboyControls.style.display = 'inline-flex';
                gameboyControls.style.marginLeft = '10px';
                
                var waveGroup = document.createElement('div');
                waveGroup.className = 'control-group';
                waveGroup.style.marginRight = '10px';
                
                var waveLabel = document.createElement('label');
                waveLabel.textContent = 'Wave';
                waveLabel.style.marginBottom = '5px';
                waveLabel.style.fontSize = '0.8em';
                
                var waveSelect = document.createElement('select');
                waveSelect.id = 'gameboy-wave';
                waveSelect.style.width = '120px';
                
                var squareOption = document.createElement('option');
                squareOption.value = 'square';
                squareOption.textContent = 'Pulse (50%)';
                waveSelect.appendChild(squareOption);
                
                var sawtoothOption = document.createElement('option');
                sawtoothOption.value = 'sawtooth';
                sawtoothOption.textContent = 'Pulse (25%)';
                waveSelect.appendChild(sawtoothOption);
                
                var triangleOption = document.createElement('option');
                triangleOption.value = 'triangle';
                triangleOption.textContent = 'Triangle';
                waveSelect.appendChild(triangleOption);
                
                waveGroup.appendChild(waveLabel);
                waveGroup.appendChild(waveSelect);
                
                var noiseGroup = document.createElement('div');
                noiseGroup.className = 'control-group';
                noiseGroup.style.marginRight = '10px';
                
                var noiseLabel = document.createElement('label');
                noiseLabel.textContent = 'Noise';
                noiseLabel.style.marginBottom = '5px';
                noiseLabel.style.fontSize = '0.8em';
                
                var noiseSelect = document.createElement('select');
                noiseSelect.id = 'gameboy-noise';
                noiseSelect.style.width = '120px';
                
                var whiteOption = document.createElement('option');
                whiteOption.value = 'white';
                whiteOption.textContent = 'White Noise';
                noiseSelect.appendChild(whiteOption);
                
                var pinkOption = document.createElement('option');
                pinkOption.value = 'pink';
                pinkOption.textContent = 'Pink Noise';
                noiseSelect.appendChild(pinkOption);
                
                noiseGroup.appendChild(noiseLabel);
                noiseGroup.appendChild(noiseSelect);
                
                var attackGroup = document.createElement('div');
                attackGroup.className = 'control-group';
                attackGroup.style.marginRight = '10px';
                
                var attackLabel = document.createElement('label');
                attackLabel.textContent = 'Attack';
                attackLabel.id = 'gameboy-attack-label';
                attackLabel.style.marginBottom = '5px';
                attackLabel.style.fontSize = '0.8em';
                
                var attackSlider = document.createElement('input');
                attackSlider.type = 'range';
                attackSlider.id = 'gameboy-attack';
                attackSlider.min = '0';
                attackSlider.max = '0.5';
                attackSlider.step = '0.01';
                attackSlider.value = '0';
                attackSlider.style.width = '100px';
                
                attackSlider.addEventListener('input', function() {
                    document.getElementById('gameboy-attack-label').textContent = 'Attack';
                });
                
                attackGroup.appendChild(attackLabel);
                attackGroup.appendChild(attackSlider);
                
                var releaseGroup = document.createElement('div');
                releaseGroup.className = 'control-group';
                
                var releaseLabel = document.createElement('label');
                releaseLabel.textContent = 'Release';
                releaseLabel.id = 'gameboy-release-label';
                releaseLabel.style.marginBottom = '5px';
                releaseLabel.style.fontSize = '0.8em';
                
                var releaseSlider = document.createElement('input');
                releaseSlider.type = 'range';
                releaseSlider.id = 'gameboy-release';
                releaseSlider.min = '0';
                releaseSlider.max = '1';
                releaseSlider.step = '0.01';
                releaseSlider.value = '0.3';
                releaseSlider.style.width = '100px';
                
                releaseSlider.addEventListener('input', function() {
                    document.getElementById('gameboy-release-label').textContent = 'Release';
                });
                
                releaseGroup.appendChild(releaseLabel);
                releaseGroup.appendChild(releaseSlider);
                
                gameboyControls.appendChild(waveGroup);
                gameboyControls.appendChild(noiseGroup);
                gameboyControls.appendChild(attackGroup);
                gameboyControls.appendChild(releaseGroup);
                
                controlBar.appendChild(gameboyControls);
            }

            function removeGameBoyControls() {
                var gameboyControls = document.getElementById('gameboy-controls');
                if (gameboyControls) {
                    gameboyControls.parentNode.removeChild(gameboyControls);
                }
                
                document.querySelector('.wave-selector').style.display = 'inline-flex';
            }

            function createGuitarControls() {
                document.querySelector('.wave-selector').style.display = 'none';
                var controlBar = document.querySelector('.control-bar');
                
                var guitarControls = document.createElement('div');
                guitarControls.id = 'guitar-controls';
                guitarControls.style.display = 'inline-flex';
                guitarControls.style.marginLeft = '10px';
                
                var typeGroup = document.createElement('div');
                typeGroup.className = 'control-group';
                typeGroup.style.marginRight = '10px';
                
                var typeLabel = document.createElement('label');
                typeLabel.textContent = 'Type';
                typeLabel.style.marginBottom = '5px';
                typeLabel.style.fontSize = '0.8em';
                
                var typeSelect = document.createElement('select');
                typeSelect.id = 'guitar-type';
                typeSelect.style.width = '120px';
                
                var acousticOption = document.createElement('option');
                acousticOption.value = 'acoustic';
                acousticOption.textContent = 'Acoustic';
                typeSelect.appendChild(acousticOption);
                
                var electricOption = document.createElement('option');
                electricOption.value = 'electric';
                electricOption.textContent = 'Electric';
                typeSelect.appendChild(electricOption);
                
                var bassOption = document.createElement('option');
                bassOption.value = 'bass';
                bassOption.textContent = 'Bass';
                typeSelect.appendChild(bassOption);
                
                typeGroup.appendChild(typeLabel);
                typeGroup.appendChild(typeSelect);
                
                var dampingGroup = document.createElement('div');
                dampingGroup.className = 'control-group';
                dampingGroup.style.marginRight = '10px';
                
                var dampingLabel = document.createElement('label');
                dampingLabel.textContent = 'Damping';
                dampingLabel.id = 'guitar-damping-label';
                dampingLabel.style.marginBottom = '5px';
                dampingLabel.style.fontSize = '0.8em';
                
                var dampingSlider = document.createElement('input');
                dampingSlider.type = 'range';
                dampingSlider.id = 'guitar-damping';
                dampingSlider.min = '0.9';
                dampingSlider.max = '0.999';
                dampingSlider.step = '0.001';
                dampingSlider.value = '0.995';
                dampingSlider.style.width = '100px';
                
                dampingSlider.addEventListener('input', function() {
                    document.getElementById('guitar-damping-label').textContent = 'Damping';
                });
                
                dampingGroup.appendChild(dampingLabel);
                dampingGroup.appendChild(dampingSlider);
                
                var resonanceGroup = document.createElement('div');
                resonanceGroup.className = 'control-group';
                
                var resonanceLabel = document.createElement('label');
                resonanceLabel.textContent = 'Body';
                resonanceLabel.id = 'guitar-body-label';
                resonanceLabel.style.marginBottom = '5px';
                resonanceLabel.style.fontSize = '0.8em';
                
                var resonanceSlider = document.createElement('input');
                resonanceSlider.type = 'range';
                resonanceSlider.id = 'guitar-body';
                resonanceSlider.min = '0';
                resonanceSlider.max = '1';
                resonanceSlider.step = '0.01';
                resonanceSlider.value = '0.3';
                resonanceSlider.style.width = '100px';
                
                resonanceSlider.addEventListener('input', function() {
                    document.getElementById('guitar-body-label').textContent = 'Body';
                });
                
                resonanceGroup.appendChild(resonanceLabel);
                resonanceGroup.appendChild(resonanceSlider);
                
                guitarControls.appendChild(typeGroup);
                guitarControls.appendChild(dampingGroup);
                guitarControls.appendChild(resonanceGroup);
                
                controlBar.appendChild(guitarControls);
            }

            function removeGuitarControls() {
                var guitarControls = document.getElementById('guitar-controls');
                if (guitarControls) {
                    guitarControls.parentNode.removeChild(guitarControls);
                }
                
                document.querySelector('.wave-selector').style.display = 'inline-flex';
            }

            function createSNESControls() {
                document.querySelector('.wave-selector').style.display = 'none';
                var controlBar = document.querySelector('.control-bar');
                
                var snesControls = document.createElement('div');
                snesControls.id = 'snes-controls';
                snesControls.style.display = 'inline-flex';
                snesControls.style.marginLeft = '10px';
                
                var typeGroup = document.createElement('div');
                typeGroup.className = 'control-group';
                typeGroup.style.marginRight = '10px';
                
                var typeLabel = document.createElement('label');
                typeLabel.textContent = 'Instrument';
                typeLabel.style.marginBottom = '5px';
                typeLabel.style.fontSize = '0.8em';
                
                var typeSelect = document.createElement('select');
                typeSelect.id = 'snes-instrument';
                typeSelect.style.width = '120px';
                
                var pianoOption = document.createElement('option');
                pianoOption.value = 'piano';
                pianoOption.textContent = 'Piano';
                typeSelect.appendChild(pianoOption);
                
                var stringsOption = document.createElement('option');
                stringsOption.value = 'strings';
                stringsOption.textContent = 'Strings';
                typeSelect.appendChild(stringsOption);
                
                var brassOption = document.createElement('option');
                brassOption.value = 'brass';
                brassOption.textContent = 'Brass';
                typeSelect.appendChild(brassOption);
                
                var woodwindOption = document.createElement('option');
                woodwindOption.value = 'woodwind';
                woodwindOption.textContent = 'Woodwind';
                typeSelect.appendChild(woodwindOption);
                
                var percussionOption = document.createElement('option');
                percussionOption.value = 'percussion';
                percussionOption.textContent = 'Percussion';
                typeSelect.appendChild(percussionOption);
                
                typeGroup.appendChild(typeLabel);
                typeGroup.appendChild(typeSelect);
                
                var reverbGroup = document.createElement('div');
                reverbGroup.className = 'control-group';
                reverbGroup.style.marginRight = '10px';
                
                var reverbLabel = document.createElement('label');
                reverbLabel.textContent = 'Reverb';
                reverbLabel.id = 'snes-reverb-label';
                reverbLabel.style.marginBottom = '5px';
                reverbLabel.style.fontSize = '0.8em';
                
                var reverbSlider = document.createElement('input');
                reverbSlider.type = 'range';
                reverbSlider.id = 'snes-reverb';
                reverbSlider.min = '0';
                reverbSlider.max = '1';
                reverbSlider.step = '0.05';
                reverbSlider.value = '0.3';
                reverbSlider.style.width = '100px';
                
                reverbSlider.addEventListener('input', function() {
                    document.getElementById('snes-reverb-label').textContent = 'Reverb';
                });
                
                reverbGroup.appendChild(reverbLabel);
                reverbGroup.appendChild(reverbSlider);
                
                var attackGroup = document.createElement('div');
                attackGroup.className = 'control-group';
                attackGroup.style.marginRight = '10px';
                
                var attackLabel = document.createElement('label');
                attackLabel.textContent = 'Attack';
                attackLabel.id = 'snes-attack-label';
                attackLabel.style.marginBottom = '5px';
                attackLabel.style.fontSize = '0.8em';
                
                var attackSlider = document.createElement('input');
                attackSlider.type = 'range';
                attackSlider.id = 'snes-attack';
                attackSlider.min = '0';
                attackSlider.max = '0.5';
                attackSlider.step = '0.01';
                attackSlider.value = '0.05';
                attackSlider.style.width = '100px';
                
                attackSlider.addEventListener('input', function() {
                    document.getElementById('snes-attack-label').textContent = 'Attack';
                });
                
                attackGroup.appendChild(attackLabel);
                attackGroup.appendChild(attackSlider);
                
                var releaseGroup = document.createElement('div');
                releaseGroup.className = 'control-group';
                
                var releaseLabel = document.createElement('label');
                releaseLabel.textContent = 'Release';
                releaseLabel.id = 'snes-release-label';
                releaseLabel.style.marginBottom = '5px';
                releaseLabel.style.fontSize = '0.8em';
                
                var releaseSlider = document.createElement('input');
                releaseSlider.type = 'range';
                releaseSlider.id = 'snes-release';
                releaseSlider.min = '0';
                releaseSlider.max = '2';
                releaseSlider.step = '0.05';
                releaseSlider.value = '0.5';
                releaseSlider.style.width = '100px';
                
                releaseSlider.addEventListener('input', function() {
                    document.getElementById('snes-release-label').textContent = 'Release';
                });
                
                releaseGroup.appendChild(releaseLabel);
                releaseGroup.appendChild(releaseSlider);
                
                snesControls.appendChild(typeGroup);
                snesControls.appendChild(reverbGroup);
                snesControls.appendChild(attackGroup);
                snesControls.appendChild(releaseGroup);
                
                controlBar.appendChild(snesControls);
            }

            function removeSNESControls() {
                var snesControls = document.getElementById('snes-controls');
                if (snesControls) {
                    snesControls.parentNode.removeChild(snesControls);
                }
                
                document.querySelector('.wave-selector').style.display = 'inline-flex';
            }

            function createDrumsControls() {
                document.querySelector('.wave-selector').style.display = 'none';
                var controlBar = document.querySelector('.control-bar');
                
                var drumsControls = document.createElement('div');
                drumsControls.id = 'drums-controls';
                drumsControls.style.display = 'inline-flex';
                drumsControls.style.marginLeft = '10px';
                
                var typeGroup = document.createElement('div');
                typeGroup.className = 'control-group';
                typeGroup.style.marginRight = '10px';
                
                var typeLabel = document.createElement('label');
                typeLabel.textContent = 'Drum Type';
                typeLabel.style.marginBottom = '5px';
                typeLabel.style.fontSize = '0.8em';
                
                var typeSelect = document.createElement('select');
                typeSelect.id = 'drums-type';
                typeSelect.style.width = '120px';
                
                var kickOption = document.createElement('option');
                kickOption.value = 'kick';
                kickOption.textContent = 'Kick';
                typeSelect.appendChild(kickOption);
                
                var snareOption = document.createElement('option');
                snareOption.value = 'snare';
                snareOption.textContent = 'Snare';
                typeSelect.appendChild(snareOption);
                
                var tomOption = document.createElement('option');
                tomOption.value = 'tom';
                tomOption.textContent = 'Tom';
                typeSelect.appendChild(tomOption);
                
                var hiHatOption = document.createElement('option');
                hiHatOption.value = 'hihat';
                hiHatOption.textContent = 'Hi-Hat';
                typeSelect.appendChild(hiHatOption);
                
                var cymbalOption = document.createElement('option');
                cymbalOption.value = 'cymbal';
                cymbalOption.textContent = 'Cymbal';
                typeSelect.appendChild(cymbalOption);
                
                typeGroup.appendChild(typeLabel);
                typeGroup.appendChild(typeSelect);
                
                var pitchGroup = document.createElement('div');
                pitchGroup.className = 'control-group';
                pitchGroup.style.marginRight = '10px';
                
                var pitchLabel = document.createElement('label');
                pitchLabel.textContent = 'Pitch';
                pitchLabel.id = 'drums-pitch-label';
                pitchLabel.style.marginBottom = '5px';
                pitchLabel.style.fontSize = '0.8em';
                
                var pitchSlider = document.createElement('input');
                pitchSlider.type = 'range';
                pitchSlider.id = 'drums-pitch';
                pitchSlider.min = '0.5';
                pitchSlider.max = '2';
                pitchSlider.step = '0.1';
                pitchSlider.value = '1';
                pitchSlider.style.width = '100px';
                
                pitchSlider.addEventListener('input', function() {
                    document.getElementById('drums-pitch-label').textContent = 'Pitch';
                });
                
                pitchGroup.appendChild(pitchLabel);
                pitchGroup.appendChild(pitchSlider);
                
                var decayGroup = document.createElement('div');
                decayGroup.className = 'control-group';
                
                var decayLabel = document.createElement('label');
                decayLabel.textContent = 'Decay';
                decayLabel.id = 'drums-decay-label';
                decayLabel.style.marginBottom = '5px';
                decayLabel.style.fontSize = '0.8em';
                
                var decaySlider = document.createElement('input');
                decaySlider.type = 'range';
                decaySlider.id = 'drums-decay';
                decaySlider.min = '0.1';
                decaySlider.max = '2';
                decaySlider.step = '0.1';
                decaySlider.value = '0.5';
                decaySlider.style.width = '100px';
                
                decaySlider.addEventListener('input', function() {
                    document.getElementById('drums-decay-label').textContent = 'Decay';
                });
                
                decayGroup.appendChild(decayLabel);
                decayGroup.appendChild(decaySlider);
                
                drumsControls.appendChild(typeGroup);
                drumsControls.appendChild(pitchGroup);
                drumsControls.appendChild(decayGroup);
                
                controlBar.appendChild(drumsControls);
            }

            function removeDrumsControls() {
                var drumsControls = document.getElementById('drums-controls');
                if (drumsControls) {
                    drumsControls.parentNode.removeChild(drumsControls);
                }
                
                document.querySelector('.wave-selector').style.display = 'inline-flex';
            }
            
            function createBellControls() {
                document.querySelector('.wave-selector').style.display = 'none';
                var controlBar = document.querySelector('.control-bar');
                
                var bellControls = document.createElement('div');
                bellControls.id = 'bell-controls';
                bellControls.style.display = 'inline-flex';
                bellControls.style.marginLeft = '10px';
                
                var decayGroup = document.createElement('div');
                decayGroup.className = 'control-group';
                decayGroup.style.marginRight = '10px';
                
                var decayLabel = document.createElement('label');
                decayLabel.textContent = 'Decay';
                decayLabel.id = 'bell-decay-label';
                decayLabel.style.marginBottom = '5px';
                decayLabel.style.fontSize = '0.8em';
                
                var decaySlider = document.createElement('input');
                decaySlider.type = 'range';
                decaySlider.id = 'bell-decay';
                decaySlider.min = '0.5';
                decaySlider.max = '5.0';
                decaySlider.step = '0.1';
                decaySlider.value = '2.5';
                decaySlider.style.width = '100px';
                
                decayGroup.appendChild(decayLabel);
                decayGroup.appendChild(decaySlider);
                
                var brightGroup = document.createElement('div');
                brightGroup.className = 'control-group';
                
                var brightLabel = document.createElement('label');
                brightLabel.textContent = 'Bright';
                brightLabel.id = 'bell-brightness-label';
                brightLabel.style.marginBottom = '5px';
                brightLabel.style.fontSize = '0.8em';
                
                var brightSlider = document.createElement('input');
                brightSlider.type = 'range';
                brightSlider.id = 'bell-brightness';
                brightSlider.min = '0';
                brightSlider.max = '1';
                brightSlider.step = '0.1';
                brightSlider.value = '0.5';
                brightSlider.style.width = '100px';
                
                brightGroup.appendChild(brightLabel);
                brightGroup.appendChild(brightSlider);
                
                bellControls.appendChild(decayGroup);
                bellControls.appendChild(brightGroup);
                
                controlBar.appendChild(bellControls);
            }

            function removeBellControls() {
                var bellControls = document.getElementById('bell-controls');
                if (bellControls) {
                    bellControls.parentNode.removeChild(bellControls);
                }
                
                document.querySelector('.wave-selector').style.display = 'inline-flex';
            }
            
            function createFluteControls() {
                document.querySelector('.wave-selector').style.display = 'none';
                var controlBar = document.querySelector('.control-bar');
                
                var fluteControls = document.createElement('div');
                fluteControls.id = 'flute-controls';
                fluteControls.style.display = 'inline-flex';
                fluteControls.style.marginLeft = '10px';
                
                var breathGroup = document.createElement('div');
                breathGroup.className = 'control-group';
                breathGroup.style.marginRight = '10px';
                
                var breathLabel = document.createElement('label');
                breathLabel.textContent = 'Breath';
                breathLabel.id = 'flute-breath-label';
                breathLabel.style.marginBottom = '5px';
                breathLabel.style.fontSize = '0.8em';
                
                var breathSlider = document.createElement('input');
                breathSlider.type = 'range';
                breathSlider.id = 'flute-breath';
                breathSlider.min = '0';
                breathSlider.max = '0.5';
                breathSlider.step = '0.01';
                breathSlider.value = '0.1';
                breathSlider.style.width = '100px';
                
                breathSlider.addEventListener('input', function() {
                    document.getElementById('flute-breath-label').textContent = 'Breath';
                });

                breathGroup.appendChild(breathLabel);
                breathGroup.appendChild(breathSlider);
                
                var vibratoGroup = document.createElement('div');
                vibratoGroup.className = 'control-group';
                
                var vibratoLabel = document.createElement('label');
                vibratoLabel.textContent = 'Vibrato';
                vibratoLabel.id = 'flute-vibrato-label';
                vibratoLabel.style.marginBottom = '5px';
                vibratoLabel.style.fontSize = '0.8em';
                
                var vibratoSlider = document.createElement('input');
                vibratoSlider.type = 'range';
                vibratoSlider.id = 'flute-vibrato';
                vibratoSlider.min = '0';
                vibratoSlider.max = '10';
                vibratoSlider.step = '0.5';
                vibratoSlider.value = '5';
                vibratoSlider.style.width = '100px';
                
                vibratoSlider.addEventListener('input', function() {
                    document.getElementById('flute-vibrato-label').textContent = 'Vibrato';
                });

                vibratoGroup.appendChild(vibratoLabel);
                vibratoGroup.appendChild(vibratoSlider);
                
                fluteControls.appendChild(breathGroup);
                fluteControls.appendChild(vibratoGroup);
                
                controlBar.appendChild(fluteControls);
            }

            function removeFluteControls() {
                var fluteControls = document.getElementById('flute-controls');
                if (fluteControls) {
                    fluteControls.parentNode.removeChild(fluteControls);
                }
                
                document.querySelector('.wave-selector').style.display = 'inline-flex';
            }
            
            function createViolinControls() {
                document.querySelector('.wave-selector').style.display = 'none';
                var controlBar = document.querySelector('.control-bar');
                
                var violinControls = document.createElement('div');
                violinControls.id = 'violin-controls';
                violinControls.style.display = 'inline-flex';
                violinControls.style.marginLeft = '10px';
                
                var attackGroup = document.createElement('div');
                attackGroup.className = 'control-group';
                attackGroup.style.marginRight = '10px';
                
                var attackLabel = document.createElement('label');
                attackLabel.textContent = 'Attack';
                attackLabel.id = 'violin-attack-label';
                attackLabel.style.marginBottom = '5px';
                attackLabel.style.fontSize = '0.8em';
                
                var attackSlider = document.createElement('input');
                attackSlider.type = 'range';
                attackSlider.id = 'violin-attack';
                attackSlider.min = '0.05';
                attackSlider.max = '0.5';
                attackSlider.step = '0.01';
                attackSlider.value = '0.2';
                attackSlider.style.width = '100px';
                
                attackSlider.addEventListener('input', function() {
                    document.getElementById('violin-attack-label').textContent = 'Attack';
                });

                attackGroup.appendChild(attackLabel);
                attackGroup.appendChild(attackSlider);
                
                var vibratoGroup = document.createElement('div');
                vibratoGroup.className = 'control-group';
                vibratoGroup.style.marginRight = '10px';
                
                var vibratoLabel = document.createElement('label');
                vibratoLabel.textContent = 'Vib Rate';
                vibratoLabel.id = 'violin-vibrato-label';
                vibratoLabel.style.marginBottom = '5px';
                vibratoLabel.style.fontSize = '0.8em';
                
                var vibratoSlider = document.createElement('input');
                vibratoSlider.type = 'range';
                vibratoSlider.id = 'violin-vibrato';
                vibratoSlider.min = '0';
                vibratoSlider.max = '12';
                vibratoSlider.step = '0.5';
                vibratoSlider.value = '6';
                vibratoSlider.style.width = '100px';
                
                vibratoSlider.addEventListener('input', function() {
                    document.getElementById('violin-vibrato-label').textContent = 'Vib Rate';
                });

                vibratoGroup.appendChild(vibratoLabel);
                vibratoGroup.appendChild(vibratoSlider);

                var brightGroup = document.createElement('div');
                brightGroup.className = 'control-group';
                
                var brightLabel = document.createElement('label');
                brightLabel.textContent = 'Filter';
                brightLabel.id = 'violin-filter-label';
                brightLabel.style.marginBottom = '5px';
                brightLabel.style.fontSize = '0.8em';
                
                var brightSlider = document.createElement('input');
                brightSlider.type = 'range';
                brightSlider.id = 'violin-filter';
                brightSlider.min = '500';
                brightSlider.max = '5000';
                brightSlider.step = '100';
                brightSlider.value = '2500';
                brightSlider.style.width = '100px';
                
                brightSlider.addEventListener('input', function() {
                    document.getElementById('violin-filter-label').textContent = 'Filter';
                });

                brightGroup.appendChild(brightLabel);
                brightGroup.appendChild(brightSlider);
                
                violinControls.appendChild(attackGroup);
                violinControls.appendChild(vibratoGroup);
                violinControls.appendChild(brightGroup);
                
                controlBar.appendChild(violinControls);
            }

            function removeViolinControls() {
                var violinControls = document.getElementById('violin-controls');
                if (violinControls) {
                    violinControls.parentNode.removeChild(violinControls);
                }
                
                document.querySelector('.wave-selector').style.display = 'inline-flex';
            }
            
            function createUkuleleControls() {
                document.querySelector('.wave-selector').style.display = 'none';
                var controlBar = document.querySelector('.control-bar');
                
                var ukeControls = document.createElement('div');
                ukeControls.id = 'ukulele-controls';
                ukeControls.style.display = 'inline-flex';
                ukeControls.style.marginLeft = '10px';
                
                var decayGroup = document.createElement('div');
                decayGroup.className = 'control-group';
                decayGroup.style.marginRight = '10px';
                
                var decayLabel = document.createElement('label');
                decayLabel.textContent = 'Decay';
                decayLabel.id = 'ukulele-decay-label';
                decayLabel.style.marginBottom = '5px';
                decayLabel.style.fontSize = '0.8em';
                
                var decaySlider = document.createElement('input');
                decaySlider.type = 'range';
                decaySlider.id = 'ukulele-decay';
                decaySlider.min = '0.1';
                decaySlider.max = '1.5';
                decaySlider.step = '0.1';
                decaySlider.value = '0.8';
                decaySlider.style.width = '100px';

                decaySlider.addEventListener('input', function() {
                    document.getElementById('ukulele-decay-label').textContent = 'Decay';
                });

                decayGroup.appendChild(decayLabel);
                decayGroup.appendChild(decaySlider);
                
                var nylonGroup = document.createElement('div');
                nylonGroup.className = 'control-group';
                
                var nylonLabel = document.createElement('label');
                nylonLabel.textContent = 'Nylon';
                nylonLabel.id = 'ukulele-nylon-label';
                nylonLabel.style.marginBottom = '5px';
                nylonLabel.style.fontSize = '0.8em';
                
                var nylonSlider = document.createElement('input');
                nylonSlider.type = 'range';
                nylonSlider.id = 'ukulele-nylon';
                nylonSlider.min = '2';
                nylonSlider.max = '10';
                nylonSlider.step = '0.5';
                nylonSlider.value = '4';
                nylonSlider.style.width = '100px';

                nylonSlider.addEventListener('input', function() {
                    document.getElementById('ukulele-nylon-label').textContent = 'Nylon';
                });

                nylonGroup.appendChild(nylonLabel);
                nylonGroup.appendChild(nylonSlider);
                
                ukeControls.appendChild(decayGroup);
                ukeControls.appendChild(nylonGroup);
                
                controlBar.appendChild(ukeControls);
            }

            function removeUkuleleControls() {
                var ukeControls = document.getElementById('ukulele-controls');
                if (ukeControls) {
                    ukeControls.parentNode.removeChild(ukeControls);
                }
                
                document.querySelector('.wave-selector').style.display = 'inline-flex';
            }
            
            function createTubaControls() {
                document.querySelector('.wave-selector').style.display = 'none';
                var controlBar = document.querySelector('.control-bar');
                
                var tubaControls = document.createElement('div');
                tubaControls.id = 'tuba-controls';
                tubaControls.style.display = 'inline-flex';
                tubaControls.style.marginLeft = '10px';
                
                var attackGroup = document.createElement('div');
                attackGroup.className = 'control-group';
                attackGroup.style.marginRight = '10px';
                
                var attackLabel = document.createElement('label');
                attackLabel.textContent = 'Attack';
                attackLabel.id = 'tuba-attack-label';
                attackLabel.style.marginBottom = '5px';
                attackLabel.style.fontSize = '0.8em';
                
                var attackSlider = document.createElement('input');
                attackSlider.type = 'range';
                attackSlider.id = 'tuba-attack';
                attackSlider.min = '0.05';
                attackSlider.max = '0.5';
                attackSlider.step = '0.01';
                attackSlider.value = '0.2';
                attackSlider.style.width = '100px';
                
                attackSlider.addEventListener('input', function() {
                    document.getElementById('tuba-attack-label').textContent = 'Attack';
                });

                attackGroup.appendChild(attackLabel);
                attackGroup.appendChild(attackSlider);
                
                var releaseGroup = document.createElement('div');
                releaseGroup.className = 'control-group';
                releaseGroup.style.marginRight = '10px';
                
                var releaseLabel = document.createElement('label');
                releaseLabel.textContent = 'Release';
                releaseLabel.id = 'tuba-release-label';
                releaseLabel.style.marginBottom = '5px';
                releaseLabel.style.fontSize = '0.8em';
                
                var releaseSlider = document.createElement('input');
                releaseSlider.type = 'range';
                releaseSlider.id = 'tuba-release';
                releaseSlider.min = '0.1';
                releaseSlider.max = '1.0';
                releaseSlider.step = '0.05';
                releaseSlider.value = '0.4';
                releaseSlider.style.width = '100px';

                releaseSlider.addEventListener('input', function() {
                    document.getElementById('tuba-release-label').textContent = 'Release';
                });

                releaseGroup.appendChild(releaseLabel);
                releaseGroup.appendChild(releaseSlider);
                
                var brillGroup = document.createElement('div');
                brillGroup.className = 'control-group';
                brillGroup.style.marginRight = '10px';
                
                var brillLabel = document.createElement('label');
                brillLabel.textContent = 'Bright';
                brillLabel.id = 'tuba-brilliance-label';
                brillLabel.style.marginBottom = '5px';
                brillLabel.style.fontSize = '0.8em';
                
                var brillSlider = document.createElement('input');
                brillSlider.type = 'range';
                brillSlider.id = 'tuba-brilliance';
                brillSlider.min = '1';
                brillSlider.max = '8';
                brillSlider.step = '0.1';
                brillSlider.value = '2.5';
                brillSlider.style.width = '100px';

                brillSlider.addEventListener('input', function() {
                    document.getElementById('tuba-brilliance-label').textContent = 'Bright';
                });

                brillGroup.appendChild(brillLabel);
                brillGroup.appendChild(brillSlider);

                var vibGroup = document.createElement('div');
                vibGroup.className = 'control-group';
                
                var vibLabel = document.createElement('label');
                vibLabel.textContent = 'Vibrato';
                vibLabel.id = 'tuba-vibrato-label';
                vibLabel.style.marginBottom = '5px';
                vibLabel.style.fontSize = '0.8em';
                
                var vibSlider = document.createElement('input');
                vibSlider.type = 'range';
                vibSlider.id = 'tuba-vibrato';
                vibSlider.min = '0';
                vibSlider.max = '10';
                vibSlider.step = '0.5';
                vibSlider.value = '4';
                vibSlider.style.width = '100px';

                vibSlider.addEventListener('input', function() {
                    document.getElementById('tuba-vibrato-label').textContent = 'Vibrato';
                });

                vibGroup.appendChild(vibLabel);
                vibGroup.appendChild(vibSlider);
                
                tubaControls.appendChild(attackGroup);
                tubaControls.appendChild(releaseGroup);
                tubaControls.appendChild(brillGroup);
                tubaControls.appendChild(vibGroup);
                
                controlBar.appendChild(tubaControls);
            }

            function removeTubaControls() {
                var tubaControls = document.getElementById('tuba-controls');
                if (tubaControls) {
                    tubaControls.parentNode.removeChild(tubaControls);
                }
                
                document.querySelector('.wave-selector').style.display = 'inline-flex';
            }
            
            function createCustomControls() {
                document.querySelector('.wave-selector').style.display = 'none';
                var controlBar = document.querySelector('.control-bar');
                
                var customControls = document.createElement('div');
                customControls.id = 'custom-controls';
                customControls.style.display = 'inline-flex';
                customControls.style.marginLeft = '10px';
                customControls.style.alignItems = 'center';
                
                // Status Text
                var statusText = document.createElement('span');
                statusText.id = 'custom-status';
                statusText.textContent = 'No Sample';
                statusText.style.fontSize = '0.8em';
                statusText.style.marginRight = '10px';
                statusText.style.color = '#aaa';
                
                // Load Button
                var loadButton = document.createElement('button');
                loadButton.textContent = 'Load Audio';
                loadButton.style.fontSize = '0.8em';
                loadButton.style.padding = '5px 10px';
                loadButton.style.cursor = 'pointer';
                
                // Hidden File Input
                var fileInput = document.createElement('input');
                fileInput.type = 'file';
                fileInput.id = 'custom-sample-file';
                fileInput.accept = 'audio/*';
                fileInput.style.display = 'none';
                
                // Handle Load Button Click
                loadButton.addEventListener('click', function() {
                    // FIX: Ensure AudioContext is initialized before decoding
                    if (!audioContext) {
                        try {
                            // Try to use the global init function from the main script
                            if (typeof initAudioContext === 'function') {
                                initAudioContext();
                            } else {
                                // Fallback: Create context manually if scope is different
                                var AudioContext = window.AudioContext || window.webkitAudioContext;
                                audioContext = new AudioContext();
                                if (!mainGainNode) {
                                    // Create main gain if missing for this new context
                                    mainGainNode = audioContext.createGain();
                                    mainGainNode.connect(audioContext.destination);
                                }
                            }
                        } catch(e) {
                            console.error("Could not initialize AudioContext:", e);
                            return;
                        }
                    }
                    fileInput.click();
                });

                // Handle File Selection
                fileInput.addEventListener('change', function(e) {
                    var file = e.target.files[0];
                    if (!file) return;
                    
                    statusText.textContent = 'Loading...';
                    statusText.style.color = 'yellow';
                    
                    var reader = new FileReader();
                    reader.onload = function(evt) {
                        // audioContext is guaranteed to exist now
                        audioContext.decodeAudioData(evt.target.result, function(buffer) {
                            // Store buffer globally
                            window.customSampleBuffer = buffer;
                            
                            // Guess base frequency (assuming C4 for this synth)
                            window.customSampleBaseFreq = 261.626; 
                            
                            statusText.textContent = 'Sample Loaded';
                            statusText.style.color = '#4CAF50';
                        }, function(e) {
                            console.error("Error decoding audio data", e);
                            statusText.textContent = 'Error Decoding';
                            statusText.style.color = 'red';
                        });
                    };
                    reader.readAsArrayBuffer(file);
                });

                customControls.appendChild(statusText);
                customControls.appendChild(loadButton);
                customControls.appendChild(fileInput);
                
                controlBar.appendChild(customControls);
            }

            function removeCustomControls() {
                var customControls = document.getElementById('custom-controls');
                if (customControls) {
                    customControls.parentNode.removeChild(customControls);
                }
                
                document.querySelector('.wave-selector').style.display = 'inline-flex';
                window.customSampleBuffer = null;
                window.customSampleBaseFreq = null;
            }

            function tryInitAudioContext() {
                if (!AudioContext) {
                    console.error("Web Audio API is not supported in this browser");
                    audioSupported = false;
                    return;
                }
                
                try {
                    if (!audioContext) {
                        audioContext = new AudioContext();
                    }
                    
                    if (audioContext.state !== 'suspended') {
                        completeAudioContextInit();
                    } else {
                        if(DEBUG) {
                            console.log("Audio context created but suspended, waiting for user interaction");
                        }
                    }
                } catch (e) {
                    console.error("Error creating audio context:", e);
                    audioSupported = false;
                }
            }

            function initAudioContext() {
                if (!AudioContext) {
                    console.error("Web Audio API is not supported in this browser");
                    audioSupported = false;
                    return;
                }
                
                if (audioInitialized) {
                    if(DEBUG) {
                        console.log("Audio context already initialized");
                    }
                    return;
                }
                
                try {
                    if (!audioContext) {
                        audioContext = new AudioContext();
                    }
                    
                    completeAudioContextInit();
                    
                    if (audioContext.state === 'suspended') {
                        audioContext.resume().then(function() {
                            if(DEBUG) {
                                console.log("Audio context resumed successfully");
                                console.log("Audio context state after resume:", audioContext.state);
                            }
                        }).catch(function(e) {
                            console.error("Error resuming audio context:", e);
                        });
                    }
                } catch (e) {
                    console.error("Error initializing audio context:", e);
                    audioSupported = false;
                }
            }
            
            function completeAudioContextInit() {
                mainGainNode = audioContext.createGain();
                mainGainNode.gain.value = volumeSlider.value;
                
                var limiter = audioContext.createDynamicsCompressor();
                limiter.threshold.value = -12;
                limiter.knee.value = 0;
                limiter.ratio.value = 20;
                limiter.attack.value = 0.001;
                limiter.release.value = 0.1;
                
                mainGainNode.connect(limiter);
                limiter.connect(audioContext.destination);
                
                audioInitialized = true;
                
                if(DEBUG) {
                    console.log("Audio context initialized successfully");
                    console.log("Audio context state:", audioContext.state);
                }
                
                audioContext.addEventListener('statechange', function() {
                    if(DEBUG) {
                        console.log("Audio context state changed to:", audioContext.state);
                    }
                    
                    if (audioContext.state === 'suspended') {
                        audioContext.resume().then(function() {
                            if(DEBUG) {
                                console.log("Audio context resumed after state change");
                            }
                        }).catch(function(e) {
                            console.error("Error resuming audio context after state change:", e);
                        });
                    }
                });
            }
            
            function ensureAudioContextResumed() {
                if(!audioInitialized) {
                    tryInitAudioContext();
                }

                if (!audioContext || !audioInitialized) {
                    console.error("Audio context is not initialized");
                }
                
                if (audioContext.state === 'suspended') {
                    audioContext.resume().then(function() {
                        if(DEBUG) {
                            console.log("Audio context resumed successfully");
                        }
                    }).catch(function(e) {
                        console.error("Error resuming audio context:", e);
                    });
                    return false;
                }
                
                return true;
            }

            function createPiano() {
                var svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
                svg.setAttribute('class', 'piano-svg');
                
                var hexRadius = 50;
                var hexWidth = hexRadius * 2;
                var hexHeight = Math.sqrt(3) * hexRadius;
                var horizontalSpacing = hexRadius * 1.75;
                var verticalSpacing = hexHeight * 0.85; // This is the vertical step per row
                
                // Bounding box tracking
                var minX = Infinity, maxX = -Infinity;
                var minY = Infinity, maxY = -Infinity;

                function getHexagonPoints(cx, cy, radius) {
                    var points = [];
                    for (var i = 0; i < 6; i++) {
                        var angle = (Math.PI / 3) * i - Math.PI / 2;
                        var x = cx + radius * Math.cos(angle);
                        var y = cy + radius * Math.sin(angle);
                        points.push(x + ',' + y);
                    }
                    return points.join(' ');
                }
                
                // Generate Grid
                for (var i = 0; i < noteRows.length; i++) {
                    var rowData = noteRows[i];
                    var rowOffsetX = (i % 2 === 1) ? horizontalSpacing / 2 : 0;
                    var rowOffsetY = i * verticalSpacing;
                    
                    for (var j = 0; j < rowData.length; j++) {
                        var noteData = rowData[j];
                        var cx = rowOffsetX + hexRadius + (j * horizontalSpacing);
                        var cy = rowOffsetY + hexRadius;
                        
                        // Update Bounding Box (The Center +/- Radius)
                        if (cx - hexRadius < minX) minX = cx - hexRadius;
                        if (cx + hexRadius > maxX) maxX = cx + hexRadius;
                        if (cy - hexRadius < minY) minY = cy - hexRadius;
                        if (cy + hexRadius > maxY) maxY = cy + hexRadius;

                        var g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                        g.setAttribute('class', 'hexagon-group');
                        
                        var polygon = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
                        polygon.setAttribute('class', 'hexagon');
                        polygon.setAttribute('id', noteData.note);
                        polygon.setAttribute('points', getHexagonPoints(cx, cy, hexRadius));
                        polygon.setAttribute('data-key', noteData.key);
                        polygon.setAttribute('data-note', noteData.note);
                        polygon.setAttribute('data-freq', noteData.freq);
                        polygon.setAttribute('data-note-name', noteData.note.replace(/[0-9]/, ''));
                        
                        var noteText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                        noteText.setAttribute('class', 'note-text');
                        noteText.setAttribute('x', cx);
                        noteText.setAttribute('y', cy);
                        noteText.textContent = noteData.note;
                        
                        var keyText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                        keyText.setAttribute('class', 'note-key');
                        keyText.setAttribute('x', cx);
                        keyText.setAttribute('y', cy + 20);
                        keyText.textContent = noteData.key === 'Shift' ? '' : noteData.key;
                        
                        g.appendChild(polygon);
                        g.appendChild(noteText);
                        g.appendChild(keyText);
                        svg.appendChild(g);
                        
                        notesByKey[noteData.key] = noteData;
                        notesByNoteName[noteData.note] = notesByNoteName[noteData.note] || [];
                        notesByNoteName[noteData.note].push(polygon);
                    }
                }
                
                // Set ViewBox to exactly encompass the grid
                var totalWidth = maxX - minX;
                var totalHeight = maxY - minY;
                var padding = 0; // Add some padding around edges
                var vbWidth = totalWidth + padding;
                var vbHeight = totalHeight + padding;

                svg.setAttribute('viewBox', (minX - padding/2) + ' ' + (minY - padding/2) + ' ' + vbWidth + ' ' + vbHeight);
                
                hexboard.appendChild(svg);
            }
            
            /* --- AUDIO PLAYBACK --- */
            function playNote(note, freq) {
                if (!audioSupported) {
                    console.warn("Audio is not supported in this browser");
                    return;
                }

                if (!audioContext) {
                    if(DEBUG) console.log("Creating new AudioContext...");
                    audioContext = new (window.AudioContext || window.webkitAudioContext)();
                }

                if (audioContext.state === 'suspended') {
                    if(DEBUG) console.log("AudioContext is suspended. Resuming...");
                    audioContext.resume().then(function() {
                        if(DEBUG) console.log("AudioContext resumed. Playing note:", note);
                        continuePlayingNote(note, freq);
                    }).catch(function(e) {
                        console.error("Error resuming audio context:", e);
                    });
                } else {
                    continuePlayingNote(note, freq);
                }
            }
            
            function continuePlayingNote(note, freq) {
                if (!mainGainNode) {
                    if(DEBUG) console.log("Creating mainGainNode...");
                    mainGainNode = audioContext.createGain();
                    mainGainNode.gain.value = volumeSlider.value;
                    mainGainNode.connect(audioContext.destination);
                }

                if(DEBUG) console.log("Audio context is running. Playing note:", note);

                if (activeOscillators[note]) {
                    stopNote(note);
                }

                if (currentInstrumentInstance) {
                    currentInstrumentInstance.playNote(note, freq);
                }
            }
            
            function stopNote(note) {
                if (!audioSupported || !audioContext) return;
                
                if (!activeOscillators[note]) {
                    if(DEBUG) {
                        console.log("Note is not playing:", note);
                    }
                    return;
                }
                
                if (currentInstrumentInstance) {
                    currentInstrumentInstance.stopNote(note);
                }
            }

            /* --- VISUAL FEEDBACK --- */
            function showKeyPress(note) {
                var hexes = notesByNoteName[note];
                if (hexes) {
                    for (var i = 0; i < hexes.length; i++) {
                        hexes[i].classList.add('active');
                    }
                }
            }

            function hideKeyPress(note) {
                var hexes = notesByNoteName[note];
                if (hexes) {
                    for (var i = 0; i < hexes.length; i++) {
                        hexes[i].classList.remove('active');
                    }
                }
            }

            /* --- EVENT HANDLERS --- */
            function handleNoteOn(noteData, pointerId) {
                if (!noteData) return;
                var note = noteData.note;
                var freq = noteData.freq;
                
                playNote(note, freq);
                showKeyPress(note);
                if (pointerId !== undefined) notesByPointerId[pointerId] = noteData;

                if (isRecording) {
                    var currentTime = performance.now();
                    
                    if (firstNoteTime === null) {
                        firstNoteTime = currentTime;
                    }
                    
                    recordingActiveNotes[note] = {
                        freq: freq,
                        startTime: currentTime
                    };
                }
            }

            function handleNoteOff(noteData, pointerId) {
                if (!noteData) return;
                var note = noteData.note;

                stopNote(note);
                hideKeyPress(note);
                if (pointerId !== undefined) delete notesByPointerId[pointerId];

                if (isRecording && recordingActiveNotes[note]) {
                    var noteStartData = recordingActiveNotes[note];
                    var noteEndTime = performance.now();
                    var durationMs = noteEndTime - noteStartData.startTime;

                    if (durationMs > 20) {
                        recordedMelody.push({
                            note: note,
                            freq: noteStartData.freq,
                            time: noteStartData.startTime - firstNoteTime,
                            duration: durationMs
                        });
                    }
                    delete recordingActiveNotes[note];
                }
            }

            function addEventListeners() {
                hexboard.addEventListener('mousedown', function(e) {
                    var hex = e.target;
                    if (hex.classList.contains('hexagon')) {
                        e.preventDefault();
                        isDragging = true;
                        var noteData = { 
                            note: hex.getAttribute('data-note'), 
                            freq: parseFloat(hex.getAttribute('data-freq')) 
                        };
                        currentMouseNote = noteData;
                        handleNoteOn(noteData);
                    }
                });

                document.addEventListener('mousemove', function(e) {
                    if (!isDragging) return;
                    
                    var hex = document.elementFromPoint(e.clientX, e.clientY);
                    if (hex && hex.classList.contains('hexagon')) {
                        var noteData = { 
                            note: hex.getAttribute('data-note'), 
                            freq: parseFloat(hex.getAttribute('data-freq')) 
                        };
                        
                        if (!currentMouseNote || currentMouseNote.note !== noteData.note) {
                            if (currentMouseNote) {
                                handleNoteOff(currentMouseNote);
                            }
                            handleNoteOn(noteData);
                            currentMouseNote = noteData;
                        }
                    }
                });

                document.addEventListener('mouseup', function(e) {
                    if (!isDragging) return;
                    
                    isDragging = false;
                    if (currentMouseNote) {
                        handleNoteOff(currentMouseNote);
                        currentMouseNote = null;
                    }
                    
                    for (var note in activeOscillators) {
                        stopNote(note);
                        hideKeyPress(note);
                    }
                });

                hexboard.addEventListener('touchstart', function(e) {
                    var hex = e.target;
                    if (hex.classList.contains('hexagon')) {
                        e.preventDefault();
                        isDragging = true;
                        var touch = e.touches[0];
                        var noteData = { 
                            note: hex.getAttribute('data-note'), 
                            freq: parseFloat(hex.getAttribute('data-freq')) 
                        };
                        handleNoteOn(noteData, touch.identifier);
                    }
                });

                document.addEventListener('touchmove', function(e) {
                    if (!isDragging) return;
                    
                    var touch = e.touches[0];
                    var hex = document.elementFromPoint(touch.clientX, touch.clientY);
                    if (hex && hex.classList.contains('hexagon')) {
                        var noteData = { 
                            note: hex.getAttribute('data-note'), 
                            freq: parseFloat(hex.getAttribute('data-freq')) 
                        };
                        var currentNoteData = notesByPointerId[touch.identifier];
                        
                        if (!currentNoteData || currentNoteData.note !== noteData.note) {
                            if (currentNoteData) {
                                handleNoteOff(currentNoteData, touch.identifier);
                            }
                            handleNoteOn(noteData, touch.identifier);
                        }
                    }
                });

                document.addEventListener('touchend', function(e) {
                    if (!isDragging) return;
                    
                    isDragging = false;
                    for (var i = 0; i < e.changedTouches.length; i++) {
                        var touch = e.changedTouches[i];
                        var noteData = notesByPointerId[touch.identifier];
                        if (noteData) {
                            handleNoteOff(noteData, touch.identifier);
                        }
                    }
                    
                    for (var note in activeOscillators) {
                        stopNote(note);
                        hideKeyPress(note);
                    }
                });

                window.addEventListener('keydown', function(e) {
                    if (e.repeat || e.metaKey || e.ctrlKey) return;
                    var key = e.key;
                    
                    var noteData = notesByKey[key];
                    if (noteData) {
                        e.preventDefault();
                        handleNoteOn(noteData);
                    }
                });

                window.addEventListener('keyup', function(e) {
                    var key = e.key;
                    
                    var noteData = notesByKey[key];
                    if (noteData) {
                        e.preventDefault();
                        handleNoteOff(noteData);
                    }
                });

                recordButton.addEventListener('click', toggleRecording);
                
                panelCloseBtn.addEventListener('click', closePanel);
                
                playButton.addEventListener('mousedown', startLongPress);
                playButton.addEventListener('mouseup', endLongPress);
                playButton.addEventListener('mouseleave', cancelLongPress);
                playButton.addEventListener('touchstart', startLongPress);
                playButton.addEventListener('touchend', endLongPress);
                playButton.addEventListener('touchcancel', cancelLongPress);
                
                instrumentButton.addEventListener('click', function(e) {
                    e.stopPropagation();
                    instrumentDropdown.classList.toggle('active');
                });
                
                document.addEventListener('click', function() {
                    instrumentDropdown.classList.remove('active');
                });
                
                var waveOptions = document.querySelectorAll('.wave-option');
                for (var i = 0; i < waveOptions.length; i++) {
                    waveOptions[i].addEventListener('click', function() {
                        for (var j = 0; j < waveOptions.length; j++) {
                            waveOptions[j].classList.remove('selected');
                        }
                        
                        this.classList.add('selected');
                    });
                }
                
                document.querySelector('.wave-option[data-wave-type="sine"]').classList.add('selected');
                
                fullscreenButton.addEventListener('click', toggleFullscreen);
                volumeSlider.addEventListener('input', function(e) {
                    if (mainGainNode) mainGainNode.gain.value = e.target.value;
                });
                
                /*
                 btnExportJson.addEventListener('click', exportMelody);
                */
                btnImportJson.addEventListener('click', function() {
                    fileInput.click();
                });
                
                fileInput.addEventListener('change', importMelody);
                
                btnImportAudio.addEventListener('click', function() {
                    audioFileInput.click();
                });
                
                audioFileInput.addEventListener('change', convertAudioFile);
            }

            /* --- PANEL FUNCTIONS --- */
            function startLongPress(e) {
                e.preventDefault();
                longPressTimer = setTimeout(function() {
                    openPanel();
                    panelOpen = true;
                }, longPressDelay);
            }

            function endLongPress(e) {
                if (longPressTimer) {
                    clearTimeout(longPressTimer);
                    longPressTimer = null;
                }
                
                if (!panelOpen) {
                    togglePlayback();
                }
                
                setTimeout(function() {
                    panelOpen = false;
                }, 100);
            }

            function cancelLongPress(e) {
                if (longPressTimer) {
                    clearTimeout(longPressTimer);
                    longPressTimer = null;
                }
            }

            function openPanel() {
                overlayPanel.classList.add('active');
                longPressTimer = null;
                updatePanelContent();
            }

            function closePanel() {
                overlayPanel.classList.remove('active');
            }
            
            function updatePanelContent() {
                panelContent.innerHTML = '';
                
                if (recordedMelody.length === 0) {
                    var emptyMessage = document.createElement('div');
                    emptyMessage.textContent = 'No melody recorded yet. Record a melody to see it here.';
                    emptyMessage.style.textAlign = 'center';
                    emptyMessage.style.padding = '20px';
                    panelContent.appendChild(emptyMessage);
                    return;
                }
                
                var headerRow = document.createElement('div');
                headerRow.className = 'note-list-header';
                
                var headerNote = document.createElement('div');
                headerNote.className = 'note-name';
                headerNote.textContent = 'Note';
                
                var headerFreq = document.createElement('div');
                headerFreq.className = 'note-freq';
                headerFreq.textContent = 'Freq. (Hz)';
                
                var headerTime = document.createElement('div');
                headerTime.className = 'note-time';
                headerTime.textContent = 'Time (ms)';
                
                var headerDuration = document.createElement('div');
                headerDuration.className = 'note-duration';
                headerDuration.textContent = 'Duration (ms)';
                
                headerRow.appendChild(headerNote);
                headerRow.appendChild(headerFreq);
                headerRow.appendChild(headerTime);
                headerRow.appendChild(headerDuration);
                
                panelContent.appendChild(headerRow);
                
                for (var i = 0; i < recordedMelody.length; i++) {
                    var note = recordedMelody[i];
                    var noteItem = document.createElement('div');
                    noteItem.className = 'note-item';
                    
                    var noteName = document.createElement('div');
                    noteName.className = 'note-name';
                    noteName.textContent = note.note;
                    
                    var noteFreq = document.createElement('div');
                    noteFreq.className = 'note-freq';
                    noteFreq.textContent = note.freq.toFixed(3);
                    
                    var noteTime = document.createElement('div');
                    noteTime.className = 'note-time';
                    noteTime.textContent = note.time.toFixed(0);
                    
                    var noteDuration = document.createElement('div');
                    noteDuration.className = 'note-duration';
                    noteDuration.textContent = note.duration.toFixed(0);
                    
                    noteItem.appendChild(noteName);
                    noteItem.appendChild(noteFreq);
                    noteItem.appendChild(noteTime);
                    noteItem.appendChild(noteDuration);
                    
                    panelContent.appendChild(noteItem);
                }
            }
            
            /* --- IMPORT/EXPORT FUNCTIONS --- */
            function exportMelody() {
                if (recordedMelody.length === 0) {
                    alert('No melody to export. Record a melody first.');
                    return;
                }
                
                var melodyData = {
                    name: 'Hexano Melody',
                    date: new Date().toISOString(),
                    notes: recordedMelody
                };
                
                var dataStr = JSON.stringify(melodyData, null, 2);
                var dataUri = 'data:application/json;charset=utf-8,'+ encodeURIComponent(dataStr);
                
                var exportFileDefaultName = 'hexano.json';
                
                var linkElement = document.createElement('a');
                linkElement.setAttribute('href', dataUri);
                linkElement.setAttribute('download', exportFileDefaultName);
                linkElement.click();
            }
            
            function exportWav() {
                if (recordedMelody.length === 0) {
                    alert('No melody to export. Record a melody first.');
                    return;
                }
                
                // Show UI feedback before starting the heavy render process
                progressContainer.classList.add('active');
                progressText.textContent = 'Rendering audio file...';
                progressFill.style.width = '10%';
                
                // Call the existing generateWav function
                generateWav();
            }
            
            function importMelody(event) {
                var file = event.target.files[0];
                if (!file) return;
                
                var reader = new FileReader();
                reader.onload = function(e) {
                    try {
                        var melodyData = JSON.parse(e.target.result);
                        
                        if (!melodyData.notes || !Array.isArray(melodyData.notes)) {
                            throw new Error('Invalid melody file format');
                        }
                        
                        recordedMelody = melodyData.notes;
                        
                        updatePanelContent();
                        
                        alert('Melody imported successfully!');
                    } catch (error) {
                        alert('Error importing melody: ' + error.message);
                    }
                };
                
                reader.readAsText(file);
                
                event.target.value = '';
            }

            /* --- AUDIO CONVERSION FUNCTIONS --- */
            function convertAudioFile(event) {
                var file = event.target.files[0];
                if (!file) return;
                
                if (!audioInitialized) {
                    initAudioContext();
                }
                
                progressContainer.classList.add('active');
                progressText.textContent = 'Loading audio file...';
                progressFill.style.width = '10%';
                
                var reader = new FileReader();
                reader.onload = function(e) {
                    audioContext.decodeAudioData(e.target.result)
                        .then(function(buffer) {
                            progressText.textContent = 'Analyzing frequencies...';
                            progressFill.style.width = '30%';
                            
                            var duration = buffer.duration;
                            
                            analyzeAudioBuffer(buffer)
                                .then(function(melody) {
                                    progressText.textContent = 'Processing melody...';
                                    progressFill.style.width = '70%';
                                    
                                    recordedMelody = melody;
                                    
                                    updatePanelContent();
                                    
                                    progressText.textContent = 'Complete!';
                                    progressFill.style.width = '100%';
                                    
                                    setTimeout(function() {
                                        progressContainer.classList.remove('active');
                                        progressFill.style.width = '0%';
                                    }, 1000);
                                })
                                .catch(function(error) {
                                    console.error('Error analyzing audio:', error);
                                    progressText.textContent = 'Error: ' + error.message;
                                    
                                    setTimeout(function() {
                                        progressContainer.classList.remove('active');
                                        progressFill.style.width = '0%';
                                    }, 3000);
                                });
                        })
                        .catch(function(error) {
                            console.error('Error decoding audio data:', error);
                            progressText.textContent = 'Error decoding audio: ' + error.message;
                            
                            setTimeout(function() {
                                progressContainer.classList.remove('active');
                                progressFill.style.width = '0%';
                            }, 3000);
                        });
                };

                reader.readAsArrayBuffer(file);
                
                event.target.value = '';
            }

            function analyzeAudioBuffer(buffer) {
                return new Promise(function(resolve, reject) {
                    try {
                        var sampleRate = buffer.sampleRate;
                        var channelData = buffer.getChannelData(0);
                        
                        var analysisContext = new AudioContext();
                        
                        var source = analysisContext.createBufferSource();
                        source.buffer = buffer;
                        
                        var analyzer = analysisContext.createAnalyser();
                        analyzer.fftSize = 4096;
                        analyzer.smoothingTimeConstant = 0.7;
                        analyzer.minDecibels = -70;
                        analyzer.maxDecibels = -20;
                        
                        source.connect(analyzer);
                        
                        var melody = [];
                        var currentNotes = {};
                        var noteStartTime = {};
                        var noteConfirmCount = {};
                        var analysisComplete = false;
                        
                        var minNoteDuration = 100;
                        var noteThreshold = 25;
                        var frequencyResolution = sampleRate / analyzer.fftSize;
                        var confirmThreshold = 3;
                        
                        var bufferLength = analyzer.frequencyBinCount;
                        var dataArray = new Uint8Array(bufferLength);
                        
                        function findPeaks(dataArray, threshold) {
                            var peaks = [];
                            
                            for (var i = 2; i < dataArray.length - 2; i++) {
                                if (dataArray[i] < threshold) continue;
                                
                                if (dataArray[i] > dataArray[i-1] && dataArray[i] > dataArray[i+1] &&
                                    dataArray[i] > dataArray[i-2] && dataArray[i] > dataArray[i+2] &&
                                    dataArray[i] > dataArray[i-3] && dataArray[i] > dataArray[i+3]) {
                                    
                                    var frequency = i * frequencyResolution;
                                    
                                    if (frequency >= 50 && frequency <= 5000) {
                                        peaks.push({
                                            index: i,
                                            frequency: frequency,
                                            amplitude: dataArray[i]
                                        });
                                    }
                                }
                            }
                            
                            peaks.sort(function(a, b) {
                                return b.amplitude - a.amplitude;
                            });
                            
                            return peaks.slice(0, 6);
                        }
                        
                        function analyze() {
                            if (analysisComplete) return;
                            
                            analyzer.getByteFrequencyData(dataArray);
                            
                            var peaks = findPeaks(dataArray, noteThreshold);
                            
                            var currentTime = source.context.currentTime * 1000;
                            
                            var detectedNotes = {};
                            
                            for (var i = 0; i < peaks.length; i++) {
                                var nearestNote = findNearestNote(peaks[i].frequency);
                                
                                if (nearestNote) {
                                    detectedNotes[nearestNote.note] = nearestNote;
                                }
                            }
                            
                            for (var noteName in detectedNotes) {
                                if (!currentNotes[noteName]) {
                                    noteConfirmCount[noteName] = (noteConfirmCount[noteName] || 0) + 1;
                                    
                                    if (noteConfirmCount[noteName] >= confirmThreshold) {
                                        currentNotes[noteName] = detectedNotes[noteName];
                                        noteStartTime[noteName] = currentTime;
                                    }
                                } else {
                                    noteConfirmCount[noteName] = confirmThreshold;
                                }
                            }
                            
                            for (var noteName in currentNotes) {
                                if (!detectedNotes[noteName]) {
                                    noteConfirmCount[noteName] = (noteConfirmCount[noteName] || confirmThreshold) - 1;
                                    
                                    if (noteConfirmCount[noteName] <= 0) {
                                        var duration = currentTime - noteStartTime[noteName];
                                        
                                        if (duration >= minNoteDuration) {
                                            melody.push({
                                                note: noteName,
                                                freq: currentNotes[noteName].freq,
                                                time: noteStartTime[noteName],
                                                duration: duration
                                            });
                                        }
                                        
                                        delete currentNotes[noteName];
                                        delete noteStartTime[noteName];
                                        delete noteConfirmCount[noteName];
                                    }
                                }
                            }
                            
                            var progress = (currentTime / (buffer.duration * 1000)) * 100;
                            progressFill.style.width = Math.min(progress, 100) + '%';
                            
                            if (currentTime < buffer.duration * 1000) {
                                requestAnimationFrame(analyze);
                            } else {
                                finishAnalysis();
                            }
                        }
                        
                        function finishAnalysis() {
                            if (analysisComplete) return;
                            analysisComplete = true;
                            
                            for (var noteName in currentNotes) {
                                var duration = (buffer.duration * 1000) - noteStartTime[noteName];
                                
                                if (duration >= minNoteDuration) {
                                    melody.push({
                                        note: noteName,
                                        freq: currentNotes[noteName].freq,
                                        time: noteStartTime[noteName],
                                        duration: duration
                                    });
                                }
                            }
                            
                            melody.sort(function(a, b) {
                                return a.time - b.time;
                            });
                            
                            source.stop();
                            analysisContext.close();
                            
                            progressFill.style.width = '100%';
                            
                            resolve(melody);
                        }
                        
                        source.start();
                        requestAnimationFrame(analyze);
                        
                        setTimeout(function() {
                            if (!analysisComplete) {
                                finishAnalysis();
                            }
                        }, buffer.duration * 1000 + 1000);
                        
                    } catch (error) {
                        reject(error);
                    }
                });
            }

            function findNearestNote(frequency) {
                if (frequency < 30 || frequency > 6000) {
                    return null;
                }
                
                var closestNote = null;
                var minDifference = Infinity;
                
                for (var i = 0; i < noteLayout.length; i++) {
                    var note = noteLayout[i];
                    var difference = Math.abs(frequency - note.freq);
                    
                    if (difference < minDifference) {
                        minDifference = difference;
                        closestNote = note;
                    }
                }
                
                var centsDifference = 1200 * Math.log2(frequency / closestNote.freq);
                
                if (Math.abs(centsDifference) < 50) {
                    return closestNote;
                }
                
                return null;
            }

            /* --- CONTROL BAR LOGIC --- */
            function toggleRecording() {
                if (!audioSupported) {
                    alert("Audio recording is not supported in this browser");
                    return;
                }
                
                isRecording = !isRecording;
                if (isRecording) {
                    if (isPlaying) stopPlayback();
                    recordButton.className = 'recording';
                    recordedMelody = [];
                    recordingActiveNotes = {};
                    recordingStartTime = performance.now();
                    firstNoteTime = null;
                } else {
                    recordButton.className = '';
                    var recordingStopTime = performance.now();
                    
                    for (var note in recordingActiveNotes) {
                        if (recordingActiveNotes.hasOwnProperty(note)) {
                            var noteStartData = recordingActiveNotes[note];
                            recordedMelody.push({
                                note: note,
                                freq: noteStartData.freq,
                                time: noteStartData.startTime - firstNoteTime,
                                duration: recordingStopTime - noteStartData.startTime
                            });
                        }
                    }
                    recordingActiveNotes = {};

                    if (recordedMelody.length > 0) {
                        generateWav();
                    }
                }
            }
            
            function togglePlayback() {
                if (!audioSupported) {
                    alert("Audio playback is not supported in this browser");
                    return;
                }
                
                if (isPlaying) stopPlayback();
                else if (recordedMelody.length > 0) startPlayback();
            }
            
            function startPlayback() {
                if (isRecording) toggleRecording();

                isPlaying = true;
                playIcon.style.display = 'none';
                stopIcon.style.display = 'block';
                
                if(DEBUG) {
                    console.log("Recorded Melody:");
                    console.log(recordedMelody);
                }

                if (!audioContext) {
                    audioContext = new (window.AudioContext || window.webkitAudioContext)();
                }
                
                if (audioContext.state === 'suspended') {
                    if(DEBUG) console.log("Suspending playback to resume audio context...");
                    audioContext.resume().then(function() {
                        if(DEBUG) console.log("Audio context resumed. Starting playback...");
                        continuePlayback();
                    }).catch(function(e) {
                        console.error("Error resuming audio context:", e);
                    });
                } else {
                    continuePlayback();
                }
            }
            
            function continuePlayback() {
                if(DEBUG) console.log("Starting melody playback...");

                for (var i = 0; i < recordedMelody.length; i++) {
                    var noteEvent = recordedMelody[i];
                    var noteData = { note: noteEvent.note, freq: noteEvent.freq };
                    
                    (function(note, time, duration) {
                        var playTimeout = setTimeout(function() { 
                            handleNoteOn(note); 
                        }, time);
                        var stopTimeout = setTimeout(function() { 
                            handleNoteOff(note); 
                        }, time + duration);
                        playbackTimeouts.push(playTimeout, stopTimeout);
                    })(noteData, noteEvent.time, noteEvent.duration);
                }
                
                var totalDuration = recordedMelody.length > 0 ? 
                    Math.max.apply(Math, recordedMelody.map(function(n) { return n.time + n.duration; })) : 0;
                var finalTimeout = setTimeout(stopPlayback, totalDuration + 500);
                playbackTimeouts.push(finalTimeout);
            }

            function stopPlayback() {
                isPlaying = false;
                playIcon.style.display = 'block';
                stopIcon.style.display = 'none';
                
                for (var i = 0; i < playbackTimeouts.length; i++) {
                    clearTimeout(playbackTimeouts[i]);
                }
                playbackTimeouts = [];
                
                for (var note in activeOscillators) {
                    stopNote(note);
                    hideKeyPress(note);
                }
            }
            
            function toggleFullscreen() {
                if (!document.fullscreenElement) {
                    if (document.documentElement.requestFullscreen) {
                        document.documentElement.requestFullscreen();
                    } else if (document.documentElement.webkitRequestFullscreen) {
                        document.documentElement.webkitRequestFullscreen();
                    } else if (document.documentElement.mozRequestFullScreen) {
                        document.documentElement.mozRequestFullScreen();
                    } else if (document.documentElement.msRequestFullscreen) {
                        document.documentElement.msRequestFullscreen();
                    }
                } else {
                    if (document.exitFullscreen) {
                        document.exitFullscreen();
                    } else if (document.webkitExitFullscreen) {
                        document.webkitExitFullscreen();
                    } else if (document.mozCancelFullScreen) {
                        document.mozCancelFullScreen();
                    } else if (document.msExitFullscreen) {
                        document.msExitFullscreen();
                    }
                }
            }
            
            document.addEventListener('fullscreenchange', function() {
                var isFullscreen = !!document.fullscreenElement;
                fullscreenEnterIcon.style.display = isFullscreen ? 'none' : 'block';
                fullscreenExitIcon.style.display = isFullscreen ? 'block' : 'none';
            });
            
            document.addEventListener('webkitfullscreenchange', function() {
                var isFullscreen = !!document.webkitFullscreenElement;
                fullscreenEnterIcon.style.display = isFullscreen ? 'none' : 'block';
                fullscreenExitIcon.style.display = isFullscreen ? 'block' : 'none';
            });
            
            document.addEventListener('mozfullscreenchange', function() {
                var isFullscreen = !!document.mozFullScreenElement;
                fullscreenEnterIcon.style.display = isFullscreen ? 'none' : 'block';
                fullscreenExitIcon.style.display = isFullscreen ? 'block' : 'none';
            });
            
            document.addEventListener('MSFullscreenChange', function() {
                var isFullscreen = !!document.msFullscreenElement;
                fullscreenEnterIcon.style.display = isFullscreen ? 'none' : 'block';
                fullscreenExitIcon.style.display = isFullscreen ? 'block' : 'none';
            });
            
            /* --- WAV EXPORT --- */
            function generateWav() {
                if (recordedMelody.length === 0 || !audioSupported) {
                    // Ensure we close the progress bar if we exit early
                    progressContainer.classList.remove('active');
                    progressFill.style.width = '0%';
                    return;
                }

                var totalMs = Math.max.apply(Math, recordedMelody.map(function(note) {
                    return note.time + note.duration;
                }));
                var durationSec = (totalMs / 1000) + 0.5;

                try {
                    var offlineContext = new OfflineAudioContext(2, Math.ceil(44100 * durationSec), 44100);
                    var masterGainNode = offlineContext.createGain();
                    masterGainNode.gain.value = 0.7;

                    var limiter = offlineContext.createDynamicsCompressor();
                    limiter.threshold.value = -10;
                    limiter.knee.value = 0;
                    limiter.ratio.value = 20;
                    limiter.attack.value = 0.001;
                    limiter.release.value = 0.1;

                    masterGainNode.connect(limiter);
                    limiter.connect(offlineContext.destination);

                    for (var i = 0; i < recordedMelody.length; i++) {
                        var note = recordedMelody[i];
                        var startTime = note.time / 1000;
                        var noteDuration = note.duration / 1000;
                        if (noteDuration <= 0.01) continue;

                        if (currentInstrumentInstance) {
                            currentInstrumentInstance.render(offlineContext, note, startTime, noteDuration, masterGainNode);
                        }
                    }

                    progressText.textContent = 'Rendering audio file...';
                    progressFill.style.width = '90%';

                    offlineContext.startRendering().then(function(renderedBuffer) {
                        var wavBlob = bufferToWave(renderedBuffer);
                        downloadBlob(wavBlob, 'hexano.wav');
                        
                        // FIX: Hide the progress bar after successful download
                        progressContainer.classList.remove('active');
                        progressFill.style.width = '0%';
                        
                    }).catch(function(e) {
                        console.error("Failed to render WAV:", e);
                        alert("Sorry, there was an error creating the audio file.");
                        
                        // FIX: Hide the progress bar on error so it doesn't get stuck
                        progressContainer.classList.remove('active');
                        progressFill.style.width = '0%';
                    });
                } catch (e) {
                    console.error("Error generating WAV:", e);
                    alert("Sorry, there was an error creating the audio file.");
                    
                    // FIX: Hide the progress bar on catch
                    progressContainer.classList.remove('active');
                    progressFill.style.width = '0%';
                }
            }

            function downloadBlob(blob, filename) {
                var url = URL.createObjectURL(blob);
                var a = document.createElement('a');
                a.style.display = 'none';
                a.href = url;
                a.download = filename;
                document.body.appendChild(a);
                a.click();
                URL.revokeObjectURL(url);
                a.parentNode.removeChild(a);
            }

            function bufferToWave(abuffer) {
                var numOfChan = abuffer.numberOfChannels,
                    length = abuffer.length * numOfChan * 2 + 44,
                    buffer = new ArrayBuffer(length),
                    view = new DataView(buffer),
                    channels = [],
                    i, sample, offset = 0, pos = 0;

                var setUint16 = function(data) {
                    view.setUint16(pos, data, true);
                    pos += 2;
                };
                var setUint32 = function(data) {
                    view.setUint32(pos, data, true);
                    pos += 4;
                };

                setUint32(0x46464952);
                setUint32(length - 8);
                setUint32(0x45564157);
                setUint32(0x20746d66);
                setUint32(16);
                setUint16(1);
                setUint16(numOfChan);
                setUint32(abuffer.sampleRate);
                setUint32(abuffer.sampleRate * 2 * numOfChan);
                setUint16(numOfChan * 2);
                setUint16(16);
                setUint32(0x61746164);
                setUint32(length - pos - 4);

                for (i = 0; i < abuffer.numberOfChannels; i++)
                    channels.push(abuffer.getChannelData(i));

                while (pos < length) {
                    for (i = 0; i < numOfChan; i++) {
                        sample = Math.max(-1, Math.min(1, channels[i][offset]));
                        sample = sample < 0 ? sample * 0x8000 : sample * 0x7FFF;
                        view.setInt16(pos, sample, true);
                        pos += 2;
                    }
                    offset++;
                }

                return new Blob([buffer], {
                    type: "audio/wav"
                });
            }

            init();
        });
    </script>
</head>
<body>
    <div class="app-container">
        <div id="control-bar" class="control-bar">
            <button id="record-button" title="Record / Stop and Save WAV">
                <div id="record-indicator"></div>
            </button>
            <button id="play-button" title="Play / Stop Melody">
                <svg id="play-icon" class="icon" viewBox="0 0 24 24">
                    <path d="M8 5v14l11-7z"/>
                </svg>
                <svg id="stop-icon" class="icon" viewBox="0 0 24 24" style="display: none;">
                    <path d="M6 6h12v12H6z"/>
                </svg>
            </button>

            <div class="instrument-selector">
                <button id="instrument-button" title="Select Instrument">
                    <svg class="icon" viewBox="0 0 24 24">
                        <path d="M12 3v10.55c-.59-.34-1.27-.55-2-.55-2.21 0-4 1.79-4 4s1.79 4 4 4 4-1.79 4-4V7h4V3h-6z"/>
                    </svg>
                </button>
                <div id="instrument-dropdown" class="instrument-dropdown">
                    <!-- Instrument options will be populated by JavaScript -->
                </div>
            </div>

            <div class="wave-selector">
                <div class="wave-option" data-wave-type="sine" title="Sine Wave">
                    <svg viewBox="0 0 60 30">
                        <path d="M0,15 Q7.5,5 15,15 T30,15 T45,15 T60,15" />
                    </svg>
                </div>
                <div class="wave-option" data-wave-type="square" title="Square Wave">
                    <svg viewBox="0 0 60 30">
                        <path d="M5,22 L15,22 L15,8 L45,8 L45,22 L55,22" />
                    </svg>
                </div>
                <div class="wave-option" data-wave-type="sawtooth" title="Sawtooth Wave">
                    <svg viewBox="0 0 60 30">
                        <path d="M0,22 L30,8 L30,22 L60,8" />
                    </svg>
                </div>
                <div class="wave-option" data-wave-type="triangle" title="Triangle Wave">
                    <svg viewBox="0 0 60 30">
                        <path d="M0,22 L15,8 L30,22 L45,8 L60,22" />
                    </svg>
                </div>
            </div>

            <input type="range" id="volume-slider" min="0" max="1" value="0.5" step="0.01" title="Volume">

            <button id="fullscreen-button" title="Toggle Fullscreen">
                <svg id="fullscreen-enter-icon" class="icon" viewBox="0 0 24 24">
                    <path d="M7 14H5v5h5v-2H7v-3zm-2-4h2V7h3V5H5v5zm12 7h-3v2h5v-5h-2v3zM14 5v2h3v3h2V5h-5z"/>
                </svg>
                <svg id="fullscreen-exit-icon" class="icon" viewBox="0 0 24 24" style="display:none;">
                    <path d="M5 16h3v3h2v-5H5v2zm3-8H5v2h5V5H8v3zm6 11h2v-3h3v-2h-5v5zm2-11V5h-2v5h5V8h-3z"/>
                </svg>
            </button>
        </div>
        <div class="hexboard-container">
            <div id="hexboard" class="hexboard">
                <!-- SVG piano will be generated here -->
            </div>
        </div>
        
        <!-- Melody Panel -->
        <div id="overlay-panel" class="overlay-panel">
            <button id="panel-close-btn" class="close-btn"></button>
            <div class="panel-header">
                <h2>Recorded Melody</h2>
            </div>
            <div id="panel-content" class="panel-content">
                <!-- Notes will be displayed here -->
            </div>
            <div class="panel-buttons">
                <button id="import-json-btn" class="panel-button">Import JSON</button>
                <button id="import-audio-btn" class="panel-button">Import Audio</button>
                <button id="export-json-btn" class="panel-button">Export JSON</button>
                <button id="export-audio-btn" class="panel-button">Export Audio</button>
                
                <input type="file" id="file-input" accept=".json" style="display: none;">
                <input type="file" id="audio-file-input" accept="audio/*" style="display: none;">
            </div>
        </div>
        
        <!-- Progress Bar for Audio Conversion -->
        <div id="progress-container" class="progress-container">
            <div id="progress-text" class="progress-text">Processing...</div>
            <div class="progress-bar">
                <div id="progress-fill" class="progress-fill"></div>
            </div>
        </div>
    </div>
</body>
</html>
