+++
title = "Beehive"
summary = "Another Prompt"
date = 2025-10-29T08:10:34+01:00
draft = false
tags = ['llm', 'ai', 'prompt']
+++
I saw a new prompt ([here](https://youtu.be/xt6_zIKeX6A?t=436)) which is better than existing ones since **LLMs** don't seem to be terained on it (yet).

It involves building a beehive simulator. While *GPT5* does indeed do it in 1 prompt it seems to be missing some polish.

```
Make a visual simulation of a beehive construction, start with a single cell and show hexagonal cells forming, worker bee trails, and honey storage. Include sliders for colony size and bee speed. Put everything in a standalone HTML file. Each cell can only be filled by 1% at a time and must be fully filled at 100% before bees make new ones. if cells get filled bees need to re-pick the target cell whether they have honey or not.
```

### GPT5's answer

```
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Beehive Construction Simulator</title>
<style>
  :root{
    --bg:#0f1419;
    --panel:#141b23;
    --wax:#f9f3d6;
    --wax-stroke:#d6cda7;
    --honey:#f2a900;
    --accent:#8bd3dd;
    --bee:#ffd84d;
    --bee-carry:#ffb703;
    --text:#e6edf3;
    --muted:#9aa6b2;
    --good:#61d095;
  }
  html,body{
    height:100%;
    margin:0;
    background:linear-gradient(180deg,#0e1318,#0f1419 15%, #0f1419 85%, #0e1318);
    color:var(--text);
    font-family:ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial, "Apple Color Emoji","Segoe UI Emoji";
    overflow:hidden;
  }
  #wrap{
    position:relative;
    width:100%;
    height:100%;
  }
  #ui{
    position:absolute;
    top:12px;
    left:12px;
    right:12px;
    display:flex;
    gap:12px;
    align-items:stretch;
    z-index:10;
    pointer-events:none;
  }
  .panel{
    background:rgba(20,27,35,.85);
    border:1px solid rgba(255,255,255,.06);
    border-radius:12px;
    box-shadow:0 8px 24px rgba(0,0,0,.35);
    padding:12px 14px;
    backdrop-filter: blur(8px);
    pointer-events:auto;
  }
  #controls{
    display:grid;
    grid-template-columns: 1fr 1fr;
    gap:10px 16px;
    min-width:360px;
    max-width:520px;
  }
  .row{
    display:grid;
    grid-template-columns:auto 1fr auto;
    align-items:center;
    gap:10px;
  }
  label{
    font-weight:600;
    color:var(--text);
    font-size:14px;
    white-space:nowrap;
  }
  input[type="range"]{
    width:100%;
  }
  .val{
    min-width:44px;
    text-align:right;
    color:var(--accent);
    font-variant-numeric: tabular-nums;
  }
  .stats{
    display:grid;
    grid-template-columns: repeat(3, auto);
    gap:12px 18px;
    align-items:center;
    font-size:13px;
    color:var(--muted);
  }
  .stat strong{
    color:var(--good);
  }
  #help{
    max-width:420px;
    line-height:1.35;
    font-size:13px;
    color:var(--muted);
  }
  #legend{
    display:flex;
    align-items:center;
    gap:10px;
    margin-top:8px;
    font-size:12px;
    color:#b6c2cf;
  }
  .dot{
    width:10px; height:10px; border-radius:50%;
    display:inline-block;
    border:1px solid rgba(0,0,0,.35);
  }
  .beeDot{ background:var(--bee); }
  .beeCarryDot{ background:var(--bee-carry); }
  .honeyDot{ background:var(--honey); }
  #canvas{
    position:absolute;
    inset:0;
    display:block;
  }
  #footer{
    position:absolute;
    bottom:10px;
    left:12px;
    right:12px;
    display:flex;
    gap:12px;
    z-index:10;
    pointer-events:none;
  }
  .pill{
    background:rgba(20,27,35,.75);
    border:1px solid rgba(255,255,255,.06);
    border-radius:999px;
    padding:8px 12px;
    pointer-events:auto;
    font-size:12px;
    color:#cbd5e1;
  }
  button{
    background:#1b2430;
    color:#dbeafe;
    border:1px solid rgba(255,255,255,.08);
    border-radius:8px;
    padding:8px 10px;
    cursor:pointer;
  }
  button:hover{ filter:brightness(1.1); }
  a{ color:#8bd3dd; text-decoration:none; }
</style>
</head>
<body>
<div id="wrap">
  <canvas id="canvas"></canvas>

  <div id="ui">
    <div class="panel" id="controls">
      <div class="row">
        <label for="colony">Colony size</label>
        <input id="colony" type="range" min="1" max="200" step="1" value="40" />
        <div class="val" id="colonyVal">40</div>
      </div>
      <div class="row">
        <label for="speed">Bee speed</label>
        <input id="speed" type="range" min="20" max="260" step="1" value="120" />
        <div class="val"><span id="speedVal">120</span> px/s</div>
      </div>
      <div class="row">
        <label for="hexSize">Cell size</label>
        <input id="hexSize" type="range" min="16" max="40" step="1" value="26" />
        <div class="val"><span id="hexSizeVal">26</span> px</div>
      </div>
      <div class="row">
        <label for="trail">Trail length</label>
        <input id="trail" type="range" min="0" max="30" step="1" value="12" />
        <div class="val"><span id="trailVal">12</span></div>
      </div>
      <div class="stats" style="grid-column: 1 / -1; margin-top:2px;">
        <div class="stat">Cells built: <strong id="cellsCount">1</strong></div>
        <div class="stat">Active fill: <strong id="activeFill">0%</strong></div>
        <div class="stat">Deposits: <strong id="depositCount">0</strong></div>
      </div>
      <div id="legend" style="grid-column: 1 / -1;">
        <span class="dot beeDot"></span> bee
        <span class="dot beeCarryDot"></span> bee carrying honey
        <span class="dot honeyDot"></span> honey level
      </div>
    </div>

    <div class="panel" id="help">
      Build logic:
      <ul style="margin:6px 0 0 18px; padding:0;">
        <li>Bees bring honey from flowers (outside) into hex cells.</li>
        <li>Each arrival deposits exactly 1% into a target cell.</li>
        <li>No new cell appears until all existing cells reach 100%.</li>
        <li>If a cell gets full, bees re-pick the target immediately, whether they have honey or not.</li>
      </ul>
      Tips:
      <ul style="margin:6px 0 0 18px; padding:0;">
        <li>Increase colony size to speed up construction.</li>
        <li>Use Bee speed to visualize path dynamics.</li>
        <li>Cell size adjusts the hex grid scale.</li>
      </ul>
    </div>
  </div>

  <div id="footer">
    <div class="pill">Pause/Play:
      <button id="toggle">Pause</button>
      <button id="reset">Reset</button>
    </div>
  </div>
</div>

<script>
;(() => {
  // --- Utility ---------------------------------------------------------------
  const clamp = (v, lo, hi) => Math.max(lo, Math.min(hi, v));
  const lerp = (a, b, t) => a + (b - a) * t;
  const rand = (a=0,b=1)=> lerp(a,b,Math.random());
  const TAU = Math.PI * 2;

  // --- Canvas and sizing -----------------------------------------------------
  const canvas = document.getElementById('canvas');
  const ctx = canvas.getContext('2d');

  const DPR = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
  let W = 0, H = 0, CX = 0, CY = 0;

  function resize() {
    W = window.innerWidth;
    H = window.innerHeight;
    canvas.width = Math.floor(W * DPR);
    canvas.height = Math.floor(H * DPR);
    canvas.style.width = W + 'px';
    canvas.style.height = H + 'px';
    ctx.setTransform(DPR, 0, 0, DPR, 0, 0);
    CX = W / 2;
    CY = H / 2 + 20; // slight vertical bias
  }
  window.addEventListener('resize', resize, {passive:true});
  resize();

  // --- Controls --------------------------------------------------------------
  const elColony = document.getElementById('colony');
  const elColonyVal = document.getElementById('colonyVal');
  const elSpeed = document.getElementById('speed');
  const elSpeedVal = document.getElementById('speedVal');
  const elHexSize = document.getElementById('hexSize');
  const elHexSizeVal = document.getElementById('hexSizeVal');
  const elTrail = document.getElementById('trail');
  const elTrailVal = document.getElementById('trailVal');
  const elCellsCount = document.getElementById('cellsCount');
  const elActiveFill = document.getElementById('activeFill');
  const elDepositCount = document.getElementById('depositCount');
  const btnToggle = document.getElementById('toggle');
  const btnReset = document.getElementById('reset');

  // Live config
  const cfg = {
    colonySize: parseInt(elColony.value,10),
    beeSpeed: parseFloat(elSpeed.value), // px/s
    hexSize: parseInt(elHexSize.value,10),
    trailLen: parseInt(elTrail.value,10),
    depositStep: 1, // percent per arrival
    arriveDist: 8,
    beeJitter: 10, // path noise toward targets
  };

  function syncControls() {
    elColonyVal.textContent = cfg.colonySize;
    elSpeedVal.textContent = cfg.beeSpeed.toFixed(0);
    elHexSizeVal.textContent = cfg.hexSize.toFixed(0);
    elTrailVal.textContent = cfg.trailLen;
  }
  syncControls();

  elColony.addEventListener('input', () => {
    cfg.colonySize = parseInt(elColony.value,10);
    elColonyVal.textContent = cfg.colonySize;
    adjustColonySize();
  });
  elSpeed.addEventListener('input', () => {
    cfg.beeSpeed = parseFloat(elSpeed.value);
    elSpeedVal.textContent = cfg.beeSpeed.toFixed(0);
  });
  elHexSize.addEventListener('input', () => {
    cfg.hexSize = parseInt(elHexSize.value,10);
    elHexSizeVal.textContent = cfg.hexSize.toFixed(0);
  });
  elTrail.addEventListener('input', () => {
    cfg.trailLen = parseInt(elTrail.value,10);
    elTrailVal.textContent = cfg.trailLen;
    // trim histories
    for (const b of bees) {
      while (b.trail.length > cfg.trailLen) b.trail.shift();
    }
  });

  let paused = false;
  btnToggle.addEventListener('click', () => {
    paused = !paused;
    btnToggle.textContent = paused ? 'Play' : 'Pause';
    if (!paused) lastT = performance.now();
  });
  btnReset.addEventListener('click', () => resetSimulation());

  // --- Hex math (axial coords, flat-topped) ---------------------------------
  // Axial dirs: E, NE, NW, W, SW, SE
  const DIRS = [
    [1, 0], [1,-1], [0,-1],
    [-1,0], [-1,1], [0,1]
  ];
  const hexAdd = (a,b)=> ({q:a.q+b.q, r:a.r+b.r});
  const hexKey = (q,r)=> `${q},${r}`;
  const hexToPixel = (q, r) => {
    const s = cfg.hexSize;
    const x = s * (3/2) * q;
    const y = s * (Math.sqrt(3) * (r + q/2));
    return { x: CX + x, y: CY + y };
  };
  function hexPolygonPath(q, r, inset = 0) {
    const {x, y} = hexToPixel(q, r);
    const s = Math.max(2, cfg.hexSize - inset);
    const ang0 = 0; // flat-topped
    ctx.beginPath();
    for (let i=0; i<6; i++) {
      const ang = ang0 + Math.PI/3 * i;
      const px = x + s * Math.cos(ang);
      const py = y + s * Math.sin(ang);
      if (i===0) ctx.moveTo(px, py);
      else ctx.lineTo(px, py);
    }
    ctx.closePath();
  }
  // ring of radius r around origin in axial coords
  function hexRing(radius) {
    const out = [];
    if (radius <= 0) return out;
    // start at (-r, r)
    let q = -radius, r = radius;
    for (let side=0; side<6; side++) {
      const [dq, dr] = DIRS[side];
      for (let i=0; i<radius; i++) {
        out.push({q, r});
        q += dq;
        r += dr;
      }
    }
    return out;
  }

  // --- Flowers (foraging targets) -------------------------------------------
  const flowers = [];
  function buildFlowers() {
    flowers.length = 0;
    const ringR = Math.max(W, H) * 0.55;
    const count = 24;
    for (let i=0; i<count; i++) {
      const a = (i / count) * TAU + rand(-0.08, 0.08);
      const r = ringR + rand(-60, 60);
      flowers.push({
        x: CX + Math.cos(a) * r,
        y: CY + Math.sin(a) * r,
        rad: rand(6, 10),
        hue: rand(250, 320)
      });
    }
  }
  buildFlowers();
  window.addEventListener('resize', buildFlowers);

  // --- Hive state ------------------------------------------------------------
  let depositEvents = 0;

  const cells = new Map(); // key -> {q,r, fill, id}
  const cellList = [];     // draw order
  let nextCellId = 0;

  // Growth plan: expand ring-by-ring from origin
  const growth = {
    nextRing: 1,
    queue: [], // pending coords to create
    idx: 0
  };

  function createCell(q, r) {
    const key = hexKey(q, r);
    if (cells.has(key)) return cells.get(key);
    const c = { id: nextCellId++, q, r, fill: 0 };
    cells.set(key, c);
    cellList.push(c);
    return c;
  }

  function seedPlanIfNeeded() {
    while (growth.idx >= growth.queue.length) {
      // append next ring
      const ringCoords = hexRing(growth.nextRing++);
      // filter out any accidental dupes (shouldn't happen)
      const unique = ringCoords.filter(({q,r}) => !cells.has(hexKey(q,r)));
      growth.queue.push(...unique);
      if (growth.nextRing > 200) break; // safety
    }
  }

  function createNextCellIfAllFull() {
    // Only create new cell if every existing cell is full (100%)
    if (cellList.length === 0) {
      // seed origin
      createCell(0,0);
      return;
    }
    const anyIncomplete = cellList.some(c => c.fill < 100);
    if (anyIncomplete) return;

    // expand: pop next planned coordinate
    seedPlanIfNeeded();
    if (growth.idx < growth.queue.length) {
      const {q, r} = growth.queue[growth.idx++];
      createCell(q, r);
    }
  }

  function pickNeedyCell() {
    // Return a cell with fill < 100, prefer lowest fill, break ties by newest
    let best = null;
    for (let i=cellList.length-1; i>=0; i--) {
      const c = cellList[i];
      if (c.fill >= 100) continue;
      if (!best || c.fill < best.fill) best = c;
    }
    return best;
  }

  // Initialize with a single cell
  function initHive() {
    cells.clear(); cellList.length = 0; nextCellId = 0;
    growth.queue.length = 0; growth.idx = 0; growth.nextRing = 1;
    createCell(0,0);
    depositEvents = 0;
  }

  // --- Bees ------------------------------------------------------------------
  const bees = [];
  let beeIdInc = 0;

  function makeBee() {
    const {x,y} = hexToPixel(0,0);
    return {
      id: beeIdInc++,
      x: x + rand(-10,10),
      y: y + rand(-10,10),
      vx: 0, vy: 0,
      carrying: Math.random() < 0.2, // some start with honey
      target: null,
      trail: [],
      wobbleT: rand(0, 1000),
      color: 'yellow',
    };
  }

  function adjustColonySize() {
    // add or remove bees to match cfg.colonySize
    while (bees.length < cfg.colonySize) {
      const b = makeBee();
      bees.push(b);
      chooseTarget(b, true);
    }
    while (bees.length > cfg.colonySize) bees.pop();
  }

  // choose a new target based on carrying
  function chooseTarget(bee, forceCellIfAvailable = false) {
    // If carrying, aim for a needy cell
    const needy = pickNeedyCell();
    if (bee.carrying && needy) {
      bee.target = { type: 'cell', id: needy.id };
      return;
    }
    // If not carrying, or no needy cell: go to a flower
    if (!bee.carrying || (!needy && !forceCellIfAvailable)) {
      const f = flowers[(Math.random() * flowers.length) | 0];
      // jitter the target point a bit so paths differ
      const jitter = 30;
      bee.target = { type: 'flower', x: f.x + rand(-jitter,jitter), y: f.y + rand(-jitter,jitter) };
      return;
    }
    // If forcing cell and one is available
    if (forceCellIfAvailable && needy) {
      bee.target = { type: 'cell', id: needy.id };
      return;
    }
    // Otherwise wander near hive center
    bee.target = { type: 'loiter', x: CX + rand(-40,40), y: CY + rand(-40,40) };
  }

  function getCellById(id) {
    for (const c of cellList) if (c.id === id) return c;
    return null;
  }

  function beeUpdate(bee, dt) {
    // Re-pick if target cell is full (regardless of carrying)
    if (bee.target && bee.target.type === 'cell') {
      const c = getCellById(bee.target.id);
      if (!c || c.fill >= 100) {
        // ensure growth if everything is full
        createNextCellIfAllFull();
        // try again
        chooseTarget(bee, true);
      }
    }

    // If there is no needy cell and bee is carrying, try to trigger growth then re-pick
    if (bee.carrying && !pickNeedyCell()) {
      createNextCellIfAllFull();
      if (pickNeedyCell()) chooseTarget(bee, true);
    }

    // steer toward target
    let tx = bee.x, ty = bee.y;
    if (bee.target) {
      if (bee.target.type === 'cell') {
        const c = getCellById(bee.target.id);
        if (c) {
          const p = hexToPixel(c.q, c.r);
          tx = p.x; ty = p.y;
        }
      } else {
        tx = bee.target.x; ty = bee.target.y;
      }
    }

    // add a small sinusoidal wobble so paths aren't too straight
    bee.wobbleT += dt * 3;
    const wobA = Math.sin(bee.wobbleT * 1.7) * cfg.beeJitter;
    const wobB = Math.cos(bee.wobbleT * 1.3) * cfg.beeJitter;
    const dx = (tx + wobA) - bee.x;
    const dy = (ty + wobB) - bee.y;
    const dist = Math.hypot(dx, dy);
    const spd = cfg.beeSpeed;
    if (dist > 0.0001) {
      const step = spd * dt;
      const t = step / dist;
      if (t >= 1) {
        bee.x = tx; bee.y = ty;
      } else {
        bee.x += dx * t;
        bee.y += dy * t;
      }
    }

    // trail
    if (cfg.trailLen > 0) {
      bee.trail.push({x: bee.x, y: bee.y, a: 1});
      while (bee.trail.length > cfg.trailLen) bee.trail.shift();
      // fade
      for (let i=0;i<bee.trail.length;i++) {
        bee.trail[i].a = (i+1) / bee.trail.length;
      }
    } else {
      bee.trail.length = 0;
    }

    // handle arrivals
    if (bee.target) {
      let atDest = false;
      if (bee.target.type === 'cell') {
        const c = getCellById(bee.target.id);
        if (c) {
          const p = hexToPixel(c.q, c.r);
          atDest = Math.hypot(bee.x - p.x, bee.y - p.y) <= cfg.arriveDist;
          if (atDest) {
            // deposit 1% only if carrying and cell not full
            if (bee.carrying && c.fill < 100) {
              c.fill = Math.min(100, c.fill + cfg.depositStep);
              depositEvents++;
              // after deposit, bee no longer carrying
              bee.carrying = false;
              // if all cells are now full, create next cell
              createNextCellIfAllFull();
            }
            // re-pick target: if still carrying, go to another needy cell; else go to flower
            chooseTarget(bee);
          }
        } else {
          // cell disappeared (shouldn't happen) -> re-pick
          chooseTarget(bee);
        }
      } else {
        // flower or loiter
        atDest = Math.hypot(bee.x - tx, bee.y - ty) <= cfg.arriveDist;
        if (atDest) {
          // simulate gathering: reaching a flower toggles carrying=true
          bee.carrying = true;
          // immediately head to a needy cell if any; if not, try to expand
          if (!pickNeedyCell()) createNextCellIfAllFull();
          chooseTarget(bee, true);
        }
      }
    }
  }

  function drawBee(bee) {
    // trail
    if (bee.trail.length > 1) {
      ctx.lineWidth = 1.5;
      ctx.lineJoin = 'round';
      ctx.lineCap = 'round';
      for (let i=1; i<bee.trail.length; i++) {
        const p0 = bee.trail[i-1];
        const p1 = bee.trail[i];
        const a = p0.a * 0.35;
        ctx.strokeStyle = `rgba(139,211,221,${a})`;
        ctx.beginPath();
        ctx.moveTo(p0.x, p0.y);
        ctx.lineTo(p1.x, p1.y);
        ctx.stroke();
      }
    }

    // bee body
    ctx.save();
    ctx.shadowColor = 'rgba(0,0,0,0.35)';
    ctx.shadowBlur = 6;
    ctx.fillStyle = bee.carrying ? '#ffb703' : '#ffd84d';
    ctx.strokeStyle = 'rgba(0,0,0,.5)';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.arc(bee.x, bee.y, 3.4, 0, TAU);
    ctx.fill();
    ctx.stroke();
    // tiny wings
    ctx.fillStyle = 'rgba(255,255,255,0.6)';
    ctx.beginPath(); ctx.ellipse(bee.x-1.5, bee.y-2.4, 1.6, 1.1, 0.6, 0, TAU); ctx.fill();
    ctx.beginPath(); ctx.ellipse(bee.x+1.6, bee.y-2.4, 1.6, 1.1, -0.6, 0, TAU); ctx.fill();
    ctx.restore();
  }

  // --- Drawing ---------------------------------------------------------------
  function drawBackground() {
    // soft vignette
    const g = ctx.createRadialGradient(CX, CY, Math.min(W,H)*0.05, CX, CY, Math.max(W,H)*0.7);
    g.addColorStop(0, 'rgba(255,255,255,0.02)');
    g.addColorStop(1, 'rgba(0,0,0,0.25)');
    ctx.fillStyle = g;
    ctx.fillRect(0,0,W,H);

    // flowers
    for (const f of flowers) {
      ctx.save();
      ctx.shadowColor = 'rgba(0,0,0,0.25)';
      ctx.shadowBlur = 8;
      ctx.fillStyle = `hsl(${f.hue},70%,60%)`;
      ctx.beginPath();
      ctx.arc(f.x, f.y, f.rad, 0, TAU);
      ctx.fill();
      // center
      ctx.fillStyle = '#ffd34d';
      ctx.beginPath(); ctx.arc(f.x, f.y, f.rad*0.35, 0, TAU); ctx.fill();
      ctx.restore();
    }
  }

  function drawCell(c) {
    const {q,r,fill} = c;

    // Base wax
    ctx.save();
    hexPolygonPath(q,r,0);
    ctx.fillStyle = '#f9f3d6';
    ctx.strokeStyle = 'rgba(0,0,0,0.18)';
    ctx.lineWidth = 1.2;
    ctx.fill();
    ctx.stroke();

    // Honey level (clip to hex and draw from bottom up)
    if (fill > 0) {
      ctx.save();
      hexPolygonPath(q,r,2);
      ctx.clip();
      const {x,y} = hexToPixel(q,r);
      const h = cfg.hexSize * 1.732; // approx hex height (sqrt(3) * size)
      const level = (fill / 100) * h;
      const top = y + (h/2) - level;
      const left = x - cfg.hexSize;
      const width = cfg.hexSize * 2;

      // gradient honey fill
      const grad = ctx.createLinearGradient(0, top, 0, top+level);
      grad.addColorStop(0, 'rgba(242,169,0,0.9)');
      grad.addColorStop(1, 'rgba(180,110,0,0.95)');

      ctx.fillStyle = grad;
      ctx.fillRect(left, top, width, level);
      ctx.restore();
    }

    // Subtle inner stroke
    ctx.globalAlpha = 0.4;
    hexPolygonPath(q,r,2);
    ctx.strokeStyle = 'rgba(0,0,0,0.25)';
    ctx.lineWidth = 0.8;
    ctx.stroke();
    ctx.globalAlpha = 1;

    // Progress text for the most recently incomplete cell (for readability)
    if (c === pickNeedyCell()) {
      const {x,y} = hexToPixel(q,r);
      ctx.fillStyle = 'rgba(0,0,0,0.5)';
      ctx.font = '600 11px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial';
      ctx.textAlign = 'center';
      ctx.fillText(fill.toFixed(0) + '%', x, y+4);
    }

    ctx.restore();
  }

  function drawHive() {
    // draw cells sorted by q+r for nice layering
    const sorted = cellList.slice().sort((a,b) => (a.q+a.r) - (b.q+b.r));
    for (const c of sorted) drawCell(c);

    // center highlight
    ctx.save();
    const {x,y} = hexToPixel(0,0);
    ctx.fillStyle = 'rgba(139,211,221,0.08)';
    ctx.beginPath(); ctx.arc(x,y, cfg.hexSize*0.5, 0, TAU); ctx.fill();
    ctx.restore();
  }

  // --- Simulation loop -------------------------------------------------------
  let lastT = performance.now();

  function update(dt) {
    // update bees
    for (const b of bees) beeUpdate(b, dt);
    // update HUD
    elCellsCount.textContent = cellList.length;
    const currentNeedy = pickNeedyCell();
    elActiveFill.textContent = currentNeedy ? (currentNeedy.fill|0) + '%' : '100%';
    elDepositCount.textContent = depositEvents.toLocaleString();
  }

  function render() {
    ctx.clearRect(0,0,W,H);
    drawBackground();
    drawHive();
    // bees on top
    for (const b of bees) drawBee(b);
  }

  function frame(t) {
    if (!paused) {
      const dt = clamp((t - lastT) / 1000, 0, 0.05);
      lastT = t;
      update(dt);
      render();
    } else {
      lastT = t;
    }
    requestAnimationFrame(frame);
  }

  // --- Reset / Init ----------------------------------------------------------
  function resetSimulation() {
    initHive();
    bees.length = 0;
    beeIdInc = 0;
    adjustColonySize();
    // Give everyone an initial target
    for (const b of bees) chooseTarget(b, true);
    lastT = performance.now();
  }

  // Boot
  initHive();
  adjustColonySize();
  for (const b of bees) chooseTarget(b, true);
  requestAnimationFrame(frame);

  // Expose for console debugging if desired
  window.__hive = { cells, cellList, bees, cfg };
})();
</script>
</body>
</html>
```
